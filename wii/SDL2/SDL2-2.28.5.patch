diff --git a/CMakeLists.txt b/CMakeLists.txt
index b38a8bbc1..e6834c350 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -141,6 +141,7 @@ check_cpu_architecture(x64 SDL_CPU_X64)
 check_cpu_architecture(arm32 SDL_CPU_ARM32)
 check_cpu_architecture(arm64 SDL_CPU_ARM64)
 check_cpu_architecture(loongarch64 SDL_CPU_LOONGARCH64)
+check_cpu_architecture(powerpc SDL_CPU_POWERPC)
 
 # Check for 64 or 32 bit
 set(SIZEOF_VOIDP ${CMAKE_SIZEOF_VOID_P})
@@ -238,7 +239,7 @@ if(USE_GCC OR USE_CLANG OR USE_INTELCC OR USE_QCC)
 endif()
 
 # Default option knobs
-if(UNIX OR MINGW OR MSYS OR (USE_CLANG AND NOT WINDOWS) OR VITA OR PSP OR PS2 OR N3DS)
+if(UNIX OR MINGW OR MSYS OR (USE_CLANG AND NOT WINDOWS) OR VITA OR PSP OR PS2 OR N3DS OR OGC)
   set(OPT_DEF_LIBC ON)
 endif()
 
@@ -350,7 +351,7 @@ if(EMSCRIPTEN)
   set(SDL_CPUINFO_ENABLED_BY_DEFAULT OFF)
 endif()
 
-if(VITA OR PSP OR PS2 OR N3DS)
+if(VITA OR PSP OR PS2 OR N3DS OR OGC)
   set(SDL_SHARED_ENABLED_BY_DEFAULT OFF)
   set(SDL_LOADSO_ENABLED_BY_DEFAULT OFF)
 endif()
@@ -840,7 +841,7 @@ if(SDL_ASSEMBLY)
 
     check_include_file("immintrin.h" HAVE_IMMINTRIN_H)
 
-    if(SDL_ALTIVEC)
+    if(SDL_ALTIVEC AND NOT OGC)
       set(CMAKE_REQUIRED_FLAGS "-maltivec")
       check_c_source_compiles("
           #include <altivec.h>
@@ -2883,6 +2884,64 @@ elseif(N3DS)
     endif()
     list(APPEND EXTRA_LIBS ${lib})
   endforeach()
+
+elseif(OGC)
+  if(CMAKE_SYSTEM_NAME MATCHES "NintendoWii")
+    file(GLOB OGC_MAIN_SOURCES ${SDL2_SOURCE_DIR}/src/main/wii/*.c)
+  else()
+    file(GLOB OGC_MAIN_SOURCES ${SDL2_SOURCE_DIR}/src/main/gamecube/*.c)
+  endif()
+  set(SDLMAIN_SOURCES ${SDLMAIN_SOURCES} ${OGC_MAIN_SOURCES})
+
+  if(SDL_AUDIO)
+    set(SDL_AUDIO_DRIVER_OGC 1)
+    file(GLOB OGC_AUDIO_SOURCES ${SDL2_SOURCE_DIR}/src/audio/ogc/*.c)
+    list(APPEND SOURCE_FILES ${OGC_AUDIO_SOURCES})
+    set(HAVE_SDL_AUDIO TRUE)
+    list(APPEND EXTRA_LIBS "aesnd")
+  endif()
+
+  if(SDL_FILESYSTEM)
+    set(SDL_FILESYSTEM_OGC 1)
+    file(GLOB OGC_FILESYSTEM_SOURCES ${SDL2_SOURCE_DIR}/src/filesystem/ogc/*.c)
+    list(APPEND SOURCE_FILES ${OGC_FILESYSTEM_SOURCES})
+    set(HAVE_SDL_FILESYSTEM TRUE)
+  endif()
+
+  if(SDL_JOYSTICK)
+    set(SDL_JOYSTICK_OGC 1)
+    file(GLOB OGC_JOYSTICK_SOURCES ${SDL2_SOURCE_DIR}/src/joystick/ogc/*.c)
+    list(APPEND SOURCE_FILES ${OGC_JOYSTICK_SOURCES})
+    set(HAVE_SDL_JOYSTICK TRUE)
+  endif()
+
+  if(SDL_THREADS)
+    set(SDL_THREAD_OGC 1)
+    file(GLOB OGC_THREAD_SOURCES ${SDL2_SOURCE_DIR}/src/thread/ogc/*.c)
+    list(APPEND SOURCE_FILES ${OGC_THREAD_SOURCES} ${SDL2_SOURCE_DIR}/src/thread/generic/SDL_systls.c)
+    set(HAVE_SDL_THREADS TRUE)
+  endif()
+
+  if(SDL_TIMERS)
+    set(SDL_TIMER_OGC 1)
+    file(GLOB OGC_TIMER_SOURCES ${SDL2_SOURCE_DIR}/src/timer/ogc/*.c)
+    list(APPEND SOURCE_FILES ${OGC_TIMER_SOURCES})
+    set(HAVE_SDL_TIMERS TRUE)
+  endif()
+
+  if(SDL_VIDEO)
+    set(SDL_VIDEO_DRIVER_OGC 1)
+    set(SDL_VIDEO_RENDER_OGC 1)
+    file(GLOB OGC_VIDEO_SOURCES ${SDL2_SOURCE_DIR}/src/video/ogc/*.c ${SDL2_SOURCE_DIR}/src/render/ogc/*.c)
+    list(APPEND SOURCE_FILES ${OGC_VIDEO_SOURCES})
+    set(SDL_VIDEO_OPENGL 0)
+    set(HAVE_SDL_VIDEO TRUE)
+  endif()
+
+  if(NOT SDL2_DISABLE_SDL2MAIN)
+    list(APPEND EXTRA_LIBS "SDL2main")
+    list(APPEND EXTRA_LIBS "fat")
+  endif()
 endif()
 
 if(HAVE_VULKAN AND NOT SDL_LOADSO)
diff --git a/cmake/CheckCPUArchitecture.cmake b/cmake/CheckCPUArchitecture.cmake
index 7e3e45947..64ddea744 100644
--- a/cmake/CheckCPUArchitecture.cmake
+++ b/cmake/CheckCPUArchitecture.cmake
@@ -34,6 +34,8 @@ function(check_cpu_architecture ARCH VARIABLE)
     _internal_check_cpu_architecture("defined(__aarch64__) || defined(_M_ARM64)" arm64 ${VARIABLE})
   elseif(ARCH STREQUAL "loongarch64")
     _internal_check_cpu_architecture("defined(__loongarch64)" loongarch64 ${VARIABLE})
+  elseif(ARCH STREQUAL "powerpc")
+    _internal_check_cpu_architecture("defined(PPC)" powerpc ${VARIABLE})
   else()
     message(WARNING "Unknown CPU architectures (${ARCH}).")
     set(${VARIABLE} FALSE)
diff --git a/cmake/sdlplatform.cmake b/cmake/sdlplatform.cmake
index 6d8ece6ac..ea0b7dd8d 100644
--- a/cmake/sdlplatform.cmake
+++ b/cmake/sdlplatform.cmake
@@ -50,6 +50,8 @@ macro(SDL_DetectCMakePlatform)
     set(SDL_CMAKE_PLATFORM HAIKU)
   elseif(NINTENDO_3DS)
     set(SDL_CMAKE_PLATFORM N3DS)
+  elseif(CMAKE_SYSTEM_NAME MATCHES "NintendoWii|NintendoGameCube")
+    set(SDL_CMAKE_PLATFORM OGC)
   elseif(OS2)
     set(SDL_CMAKE_PLATFORM OS2)
   endif()
diff --git a/docs/README-ogc.md b/docs/README-ogc.md
new file mode 100644
index 000000000..a2a1fefb5
--- /dev/null
+++ b/docs/README-ogc.md
@@ -0,0 +1,22 @@
+# Nintendo 3DS
+
+SDL port for the Nintendo GameCube and Nintendo Wii [Homebrew toolchain](https://devkitpro.org/).
+
+Credits to:
+
+-   The awesome people who ported SDL to other homebrew platforms.
+-   The Devkitpro team for making all the tools necessary to achieve this.
+
+## Building
+
+To build for the Nintendo GameCure or Wii, make sure you have devkitARM and cmake installed and run:
+
+```bash
+cmake -S. -Bbuild -DCMAKE_TOOLCHAIN_FILE="$DEVKITPRO/cmake/Wii.cmake" -DCMAKE_BUILD_TYPE=Release
+cmake --build build
+cmake --install build
+```
+
+## Notes
+
+-   Currently only software rendering is supported.
diff --git a/include/SDL_config.h.cmake b/include/SDL_config.h.cmake
index 35923d020..13f9a6022 100644
--- a/include/SDL_config.h.cmake
+++ b/include/SDL_config.h.cmake
@@ -329,6 +329,7 @@
 #cmakedefine SDL_AUDIO_DRIVER_PSP @SDL_AUDIO_DRIVER_PSP@
 #cmakedefine SDL_AUDIO_DRIVER_PS2 @SDL_AUDIO_DRIVER_PS2@
 #cmakedefine SDL_AUDIO_DRIVER_N3DS @SDL_AUDIO_DRIVER_N3DS@
+#cmakedefine SDL_AUDIO_DRIVER_OGC @SDL_AUDIO_DRIVER_OGC@
 
 /* Enable various input drivers */
 #cmakedefine SDL_INPUT_LINUXEV @SDL_INPUT_LINUXEV@
@@ -355,6 +356,7 @@
 #cmakedefine SDL_JOYSTICK_PSP @SDL_JOYSTICK_PSP@
 #cmakedefine SDL_JOYSTICK_PS2 @SDL_JOYSTICK_PS2@
 #cmakedefine SDL_JOYSTICK_N3DS @SDL_JOYSTICK_N3DS@
+#cmakedefine SDL_JOYSTICK_OGC @SDL_JOYSTICK_OGC@
 #cmakedefine SDL_HAPTIC_DUMMY @SDL_HAPTIC_DUMMY@
 #cmakedefine SDL_HAPTIC_LINUX @SDL_HAPTIC_LINUX@
 #cmakedefine SDL_HAPTIC_IOKIT @SDL_HAPTIC_IOKIT@
@@ -390,6 +392,7 @@
 #cmakedefine SDL_THREAD_PSP @SDL_THREAD_PSP@
 #cmakedefine SDL_THREAD_PS2 @SDL_THREAD_PS2@
 #cmakedefine SDL_THREAD_N3DS @SDL_THREAD_N3DS@
+#cmakedefine SDL_THREAD_OGC @SDL_THREAD_OGC@
 
 /* Enable various timer systems */
 #cmakedefine SDL_TIMER_HAIKU @SDL_TIMER_HAIKU@
@@ -401,6 +404,7 @@
 #cmakedefine SDL_TIMER_PSP @SDL_TIMER_PSP@
 #cmakedefine SDL_TIMER_PS2 @SDL_TIMER_PS2@
 #cmakedefine SDL_TIMER_N3DS @SDL_TIMER_N3DS@
+#cmakedefine SDL_TIMER_OGC @SDL_TIMER_OGC@
 
 /* Enable various video drivers */
 #cmakedefine SDL_VIDEO_DRIVER_ANDROID @SDL_VIDEO_DRIVER_ANDROID@
@@ -455,6 +459,7 @@
 #cmakedefine SDL_VIDEO_DRIVER_X11_HAS_XKBKEYCODETOKEYSYM @SDL_VIDEO_DRIVER_X11_HAS_XKBKEYCODETOKEYSYM@
 #cmakedefine SDL_VIDEO_DRIVER_VITA @SDL_VIDEO_DRIVER_VITA@
 #cmakedefine SDL_VIDEO_DRIVER_N3DS @SDL_VIDEO_DRIVER_N3DS@
+#cmakedefine SDL_VIDEO_DRIVER_OGC @SDL_VIDEO_DRIVER_OGC@
 
 #cmakedefine SDL_VIDEO_RENDER_D3D @SDL_VIDEO_RENDER_D3D@
 #cmakedefine SDL_VIDEO_RENDER_D3D11 @SDL_VIDEO_RENDER_D3D11@
@@ -467,6 +472,7 @@
 #cmakedefine SDL_VIDEO_RENDER_VITA_GXM @SDL_VIDEO_RENDER_VITA_GXM@
 #cmakedefine SDL_VIDEO_RENDER_PS2 @SDL_VIDEO_RENDER_PS2@
 #cmakedefine SDL_VIDEO_RENDER_PSP @SDL_VIDEO_RENDER_PSP@
+#cmakedefine SDL_VIDEO_RENDER_OGC @SDL_VIDEO_RENDER_OGC@
 
 /* Enable OpenGL support */
 #cmakedefine SDL_VIDEO_OPENGL @SDL_VIDEO_OPENGL@
@@ -514,6 +520,7 @@
 #cmakedefine SDL_FILESYSTEM_PSP @SDL_FILESYSTEM_PSP@
 #cmakedefine SDL_FILESYSTEM_PS2 @SDL_FILESYSTEM_PS2@
 #cmakedefine SDL_FILESYSTEM_N3DS @SDL_FILESYSTEM_N3DS@
+#cmakedefine SDL_FILESYSTEM_OGC @SDL_FILESYSTEM_OGC@
 
 /* Enable misc subsystem */
 #cmakedefine SDL_MISC_DUMMY @SDL_MISC_DUMMY@
diff --git a/include/SDL_config.h.in b/include/SDL_config.h.in
index d6460b783..026c63bad 100644
--- a/include/SDL_config.h.in
+++ b/include/SDL_config.h.in
@@ -355,6 +355,7 @@
 
 /* Enable various threading systems */
 #undef SDL_THREAD_GENERIC_COND_SUFFIX
+#undef SDL_THREAD_OGC
 #undef SDL_THREAD_PTHREAD
 #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX
 #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX_NP
diff --git a/include/SDL_main.h b/include/SDL_main.h
index 5cc8e5913..8416fb2df 100644
--- a/include/SDL_main.h
+++ b/include/SDL_main.h
@@ -117,6 +117,14 @@
 */
 #define SDL_MAIN_AVAILABLE
 
+#elif defined(__wii__) || defined(__gamecube__)
+/*
+  On Wii and GameCube, SDL provides a main function that sets up the system.
+
+  If you provide this yourself, you may define SDL_MAIN_HANDLED
+*/
+#define SDL_MAIN_AVAILABLE
+
 #endif
 #endif /* SDL_MAIN_HANDLED */
 
diff --git a/src/SDL.c b/src/SDL.c
index 56049adf0..6d164b248 100644
--- a/src/SDL.c
+++ b/src/SDL.c
@@ -610,6 +610,10 @@ const char *SDL_GetPlatform(void)
     return "Nokia N-Gage";
 #elif __3DS__
     return "Nintendo 3DS";
+#elif defined(__gamecube__)
+    return "Nintendo GameCube";
+#elif defined(__wii__)
+    return "Nintendo Wii";
 #else
     return "Unknown (see SDL_platform.h)";
 #endif
diff --git a/src/audio/SDL_audio.c b/src/audio/SDL_audio.c
index 60242e60a..0dd55916d 100644
--- a/src/audio/SDL_audio.c
+++ b/src/audio/SDL_audio.c
@@ -108,6 +108,9 @@ static const AudioBootStrap *const bootstrap[] = {
 #if SDL_AUDIO_DRIVER_N3DS
     &N3DSAUDIO_bootstrap,
 #endif
+#if SDL_AUDIO_DRIVER_OGC
+    &OGCAUDIO_bootstrap,
+#endif
 #if SDL_AUDIO_DRIVER_EMSCRIPTEN
     &EMSCRIPTENAUDIO_bootstrap,
 #endif
diff --git a/src/audio/SDL_sysaudio.h b/src/audio/SDL_sysaudio.h
index c755d4341..9da933290 100644
--- a/src/audio/SDL_sysaudio.h
+++ b/src/audio/SDL_sysaudio.h
@@ -207,6 +207,7 @@ extern AudioBootStrap PS2AUDIO_bootstrap;
 extern AudioBootStrap PSPAUDIO_bootstrap;
 extern AudioBootStrap VITAAUD_bootstrap;
 extern AudioBootStrap N3DSAUDIO_bootstrap;
+extern AudioBootStrap OGCAUDIO_bootstrap;
 extern AudioBootStrap EMSCRIPTENAUDIO_bootstrap;
 extern AudioBootStrap OS2AUDIO_bootstrap;
 
diff --git a/src/audio/ogc/SDL_ogcaudio.c b/src/audio/ogc/SDL_ogcaudio.c
new file mode 100644
index 000000000..9d70e430d
--- /dev/null
+++ b/src/audio/ogc/SDL_ogcaudio.c
@@ -0,0 +1,242 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifdef SDL_AUDIO_DRIVER_OGC
+
+#include "SDL_audio.h"
+
+/* OGC Audio driver */
+
+#include "../SDL_sysaudio.h"
+#include "SDL_ogcaudio.h"
+#include "SDL_timer.h"
+
+#include <malloc.h>
+
+#define OGCAUDIO_DRIVER_NAME "ogc"
+
+/**
+ * Cleans up all allocated memory, safe to call with null pointers
+ */
+static void FreePrivateData(_THIS)
+{
+    if (!this->hidden) {
+        return;
+    }
+
+    SDL_free(this->hidden);
+    this->hidden = NULL;
+}
+
+static int FindAudioFormat(_THIS)
+{
+    SDL_bool found_valid_format = SDL_FALSE;
+    Uint16 test_format = SDL_FirstAudioFormat(this->spec.format);
+
+    while (!found_valid_format && test_format) {
+        this->spec.format = test_format;
+        SDL_LogDebug(SDL_LOG_CATEGORY_AUDIO, "Trying format %x", test_format);
+        switch (test_format) {
+        case AUDIO_S8:
+            this->hidden->format = VOICE_MONO8;
+            this->hidden->bytes_per_sample = this->spec.channels;
+            found_valid_format = SDL_TRUE;
+            break;
+        case AUDIO_U8:
+            this->hidden->format = VOICE_MONO8_UNSIGNED;
+            this->hidden->bytes_per_sample = this->spec.channels;
+            found_valid_format = SDL_TRUE;
+            break;
+        case AUDIO_S16LSB:
+        case AUDIO_S16MSB:
+            this->hidden->format = VOICE_MONO16;
+            this->hidden->bytes_per_sample = this->spec.channels * 2;
+            this->spec.format = AUDIO_S16MSB;
+            found_valid_format = SDL_TRUE;
+            break;
+        case AUDIO_U16LSB:
+        case AUDIO_U16MSB:
+            this->hidden->format = VOICE_MONO16_UNSIGNED;
+            this->hidden->bytes_per_sample = this->spec.channels * 2;
+            this->spec.format = AUDIO_U16MSB;
+            found_valid_format = SDL_TRUE;
+            break;
+        default:
+            test_format = SDL_NextAudioFormat();
+            break;
+        }
+    }
+
+    if (found_valid_format && this->spec.channels == 2) {
+        this->hidden->format++;
+    }
+
+    return found_valid_format ? 0 : -1;
+}
+
+/* fully local functions related to the wavebufs / DSP, not the same as the SDL-wide mixer lock */
+static SDL_INLINE void contextLock(_THIS)
+{
+    LWP_MutexLock(this->hidden->lock);
+}
+
+static SDL_INLINE void contextUnlock(_THIS)
+{
+    LWP_MutexUnlock(this->hidden->lock);
+}
+
+static void audio_frame_finished(AESNDPB *pb, u32 state, void *arg)
+{
+    SDL_AudioDevice *this = (SDL_AudioDevice *)arg;
+
+    if (state == VOICE_STATE_STREAM) {
+        LWP_CondBroadcast(this->hidden->cv);
+    }
+}
+
+static int OGCAUDIO_OpenDevice(_THIS, const char *devname)
+{
+    struct SDL_PrivateAudioData *hidden =
+        memalign(32, sizeof(struct SDL_PrivateAudioData));
+    if (!hidden) {
+        return SDL_OutOfMemory();
+    }
+
+    SDL_LogDebug(SDL_LOG_CATEGORY_AUDIO,
+                 "OGCAUDIO_OpenDevice, name=%s, freq=%d, channels=%d\n",
+                 devname, this->spec.freq, this->spec.channels);
+
+    memset(hidden, 0, sizeof(*hidden));
+    this->hidden = hidden;
+
+    AESND_Init();
+    AESND_Pause(1);
+
+    /* Initialise internal state */
+    LWP_MutexInit(&hidden->lock, false);
+    LWP_CondInit(&hidden->cv);
+
+    if (this->spec.freq <= 0 || this->spec.freq > 144000)
+        this->spec.freq = DSP_DEFAULT_FREQ;
+
+    if (this->spec.channels > 2) {
+        this->spec.channels = 2;
+    }
+
+    /* Should not happen but better be safe. */
+    if (FindAudioFormat(this) < 0) {
+        return SDL_SetError("No supported audio format found.");
+    }
+
+    this->spec.samples = DMA_BUFFER_SIZE / this->hidden->bytes_per_sample;
+
+    /* Update the fragment size as size in bytes */
+    SDL_CalculateAudioSpec(&this->spec);
+
+    hidden->voice = AESND_AllocateVoiceWithArg(audio_frame_finished, this);
+    if (hidden->voice == NULL)
+        return -1;
+
+    // start audio
+    AESND_SetVoiceFormat(hidden->voice, hidden->format);
+    AESND_SetVoiceFrequency(hidden->voice, this->spec.freq);
+    AESND_SetVoiceBuffer(hidden->voice, hidden->dma_buffers[0], DMA_BUFFER_SIZE);
+    AESND_SetVoiceStream(hidden->voice, true);
+    AESND_SetVoiceStop(hidden->voice, 0);
+    AESND_Pause(0);
+
+    return 0;
+}
+
+static void OGCAUDIO_PlayDevice(_THIS)
+{
+    void *buffer;
+    size_t nextbuf;
+    size_t buffer_size = DMA_BUFFER_SIZE;
+
+    contextLock(this);
+
+    nextbuf = this->hidden->nextbuf;
+    this->hidden->nextbuf = (nextbuf + 1) % NUM_BUFFERS;
+
+    contextUnlock(this);
+
+    buffer = this->hidden->dma_buffers[nextbuf];
+    DCStoreRange(buffer, buffer_size);
+    AESND_SetVoiceBuffer(this->hidden->voice, buffer, buffer_size);
+}
+
+static void OGCAUDIO_WaitDevice(_THIS)
+{
+    contextLock(this);
+    LWP_CondWait(this->hidden->cv, this->hidden->lock);
+    contextUnlock(this);
+}
+
+static Uint8 *OGCAUDIO_GetDeviceBuf(_THIS)
+{
+    return this->hidden->dma_buffers[this->hidden->nextbuf];
+}
+
+static void OGCAUDIO_CloseDevice(_THIS)
+{
+    struct SDL_PrivateAudioData *hidden = this->hidden;
+
+    if (hidden->voice) {
+        AESND_SetVoiceStop(hidden->voice, true);
+        AESND_FreeVoice(hidden->voice);
+        hidden->voice = NULL;
+    }
+
+    AESND_Pause(1);
+    FreePrivateData(this);
+}
+
+static void OGCAUDIO_ThreadInit(_THIS)
+{
+    LWP_SetThreadPriority(LWP_THREAD_NULL, 80);
+}
+
+static SDL_bool OGCAUDIO_Init(SDL_AudioDriverImpl *impl)
+{
+    /* Set the function pointers */
+    impl->OpenDevice = OGCAUDIO_OpenDevice;
+    impl->PlayDevice = OGCAUDIO_PlayDevice;
+    impl->WaitDevice = OGCAUDIO_WaitDevice;
+    impl->GetDeviceBuf = OGCAUDIO_GetDeviceBuf;
+    impl->CloseDevice = OGCAUDIO_CloseDevice;
+    impl->ThreadInit = OGCAUDIO_ThreadInit;
+    impl->OnlyHasDefaultOutputDevice = SDL_TRUE;
+
+    return SDL_TRUE; /* this audio target is available. */
+}
+
+AudioBootStrap OGCAUDIO_bootstrap = {
+    OGCAUDIO_DRIVER_NAME,
+    "SDL OGC audio driver",
+    OGCAUDIO_Init,
+    0
+};
+
+#endif /* SDL_AUDIO_DRIVER_OGC */
+
+/* vi: set sts=4 ts=4 sw=4 expandtab: */
diff --git a/src/audio/ogc/SDL_ogcaudio.h b/src/audio/ogc/SDL_ogcaudio.h
new file mode 100644
index 000000000..151f41016
--- /dev/null
+++ b/src/audio/ogc/SDL_ogcaudio.h
@@ -0,0 +1,53 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef _SDL_ogcaudio_h_
+#define _SDL_ogcaudio_h_
+
+#include <aesndlib.h>
+#include <ogcsys.h>
+
+#include <ogc/cond.h>
+#include <ogc/mutex.h>
+
+/* Hidden "this" pointer for the audio functions */
+#define _THIS SDL_AudioDevice *this
+
+#define NUM_BUFFERS            2 /* -- Minimum 2! */
+#define SAMPLES_PER_DMA_BUFFER (DSP_STREAMBUFFER_SIZE)
+#define DMA_BUFFER_SIZE        (SAMPLES_PER_DMA_BUFFER * 2 * sizeof(short))
+
+struct SDL_PrivateAudioData
+{
+    /* these go first so they will be aligned */
+    Uint8 dma_buffers[NUM_BUFFERS][DMA_BUFFER_SIZE];
+    AESNDPB *voice;
+
+    /* Speaker data */
+    Uint32 format;
+    Uint8 bytes_per_sample;
+    Uint32 nextbuf;
+    mutex_t lock;
+    cond_t cv;
+};
+
+#endif /* _SDL_ogcaudio_h_ */
+/* vi: set sts=4 ts=4 sw=4 expandtab: */
diff --git a/src/dynapi/SDL_dynapi.h b/src/dynapi/SDL_dynapi.h
index 99ca08008..d261a33f0 100644
--- a/src/dynapi/SDL_dynapi.h
+++ b/src/dynapi/SDL_dynapi.h
@@ -67,6 +67,8 @@
 #define SDL_DYNAMIC_API 0 /* The N-Gage doesn't support dynamic linking either */
 #elif defined(__3DS__)
 #define SDL_DYNAMIC_API 0 /* devkitARM doesn't support dynamic linking */
+#elif defined(__wii__) || defined(__gamecube__)
+#define SDL_DYNAMIC_API 0 /* devkitPPC doesn't support dynamic linking */
 #elif defined(DYNAPI_NEEDS_DLOPEN) && !defined(HAVE_DLOPEN)
 #define SDL_DYNAMIC_API 0 /* we need dlopen(), but don't have it.... */
 #endif
diff --git a/src/filesystem/ogc/SDL_sysfilesystem.c b/src/filesystem/ogc/SDL_sysfilesystem.c
new file mode 100644
index 000000000..bdb34a79c
--- /dev/null
+++ b/src/filesystem/ogc/SDL_sysfilesystem.c
@@ -0,0 +1,72 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifdef SDL_FILESYSTEM_OGC
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+/* System dependent filesystem routines                                */
+
+#include <dirent.h>
+#include <errno.h>
+
+#include "SDL_error.h"
+#include "SDL_filesystem.h"
+
+static inline int create_dir(const char *dirname)
+{
+    int result = mkdir(dirname, 0666);
+
+    if (result == -1 && errno != EEXIST) {
+        return SDL_SetError("Failed to create '%s' (%s)", dirname, strerror(errno));
+    }
+    return 0;
+}
+
+char *SDL_GetBasePath(void)
+{
+    return SDL_strdup("/apps/");
+}
+
+char *SDL_GetPrefPath(const char *org, const char *app)
+{
+    char *pref_path = NULL;
+    if (!app) {
+        SDL_InvalidParamError("app");
+        return NULL;
+    }
+
+    SDL_asprintf(&pref_path, "/apps/%s/", app);
+    if (!pref_path) {
+        return NULL;
+    }
+
+    if (create_dir(pref_path) < 0) {
+        SDL_free(pref_path);
+        return NULL;
+    }
+
+    return pref_path;
+}
+
+#endif /* SDL_FILESYSTEM_OGC */
+
+/* vi: set sts=4 ts=4 sw=4 expandtab: */
diff --git a/src/joystick/SDL_joystick.c b/src/joystick/SDL_joystick.c
index 834e83d99..65dc3ce68 100644
--- a/src/joystick/SDL_joystick.c
+++ b/src/joystick/SDL_joystick.c
@@ -105,6 +105,9 @@ static SDL_JoystickDriver *SDL_joystick_drivers[] = {
 #ifdef SDL_JOYSTICK_N3DS
     &SDL_N3DS_JoystickDriver
 #endif
+#ifdef SDL_JOYSTICK_OGC
+    &SDL_OGC_JoystickDriver
+#endif
 #if defined(SDL_JOYSTICK_DUMMY) || defined(SDL_JOYSTICK_DISABLED)
         &SDL_DUMMY_JoystickDriver
 #endif
diff --git a/src/joystick/SDL_sysjoystick.h b/src/joystick/SDL_sysjoystick.h
index a93fa662c..3d3329ae5 100644
--- a/src/joystick/SDL_sysjoystick.h
+++ b/src/joystick/SDL_sysjoystick.h
@@ -249,6 +249,7 @@ extern SDL_JoystickDriver SDL_PS2_JoystickDriver;
 extern SDL_JoystickDriver SDL_PSP_JoystickDriver;
 extern SDL_JoystickDriver SDL_VITA_JoystickDriver;
 extern SDL_JoystickDriver SDL_N3DS_JoystickDriver;
+extern SDL_JoystickDriver SDL_OGC_JoystickDriver;
 
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
diff --git a/src/joystick/ogc/SDL_sysjoystick.c b/src/joystick/ogc/SDL_sysjoystick.c
new file mode 100644
index 000000000..ab84b0f37
--- /dev/null
+++ b/src/joystick/ogc/SDL_sysjoystick.c
@@ -0,0 +1,1313 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#ifdef SDL_JOYSTICK_OGC
+
+#include "../SDL_joystick_c.h"
+#include "../SDL_sysjoystick.h"
+#include "../usb_ids.h"
+#include "SDL_events.h"
+#include "SDL_hints.h"
+#include "../../SDL_hints_c.h"
+#include "SDL_joystick.h"
+
+#include <gccore.h>
+#include <math.h>
+#include <unistd.h>
+#include <wiiuse/wpad.h>
+
+#define PI 3.14159265f
+
+#define MAX_GC_JOYSTICKS  4
+#define MAX_WII_JOYSTICKS 4
+
+#define GC_JOYSTICKS_START  0
+#define GC_JOYSTICKS_END    MAX_GC_JOYSTICKS
+#define WII_JOYSTICKS_START GC_JOYSTICKS_END
+#define WII_WIIMOTES_START  WII_JOYSTICKS_START
+#define WII_WIIMOTES_END    (WII_WIIMOTES_START + MAX_WII_JOYSTICKS)
+#define WII_EXP_START       WII_WIIMOTES_END
+#define WII_EXP_END         (WII_EXP_START + MAX_WII_JOYSTICKS)
+#define WII_JOYSTICKS_END   WII_EXP_END
+
+#define MAX_JOYSTICKS WII_EXP_END
+
+#define MAX_GC_AXES    6
+#define MAX_GC_BUTTONS 8
+#define MAX_GC_HATS    1
+
+#define MAX_WII_AXES    9
+#define MAX_WII_BUTTONS 15
+#define MAX_WII_HATS    1
+
+#define JOYNAMELEN 10
+
+#define AXIS_MIN -32767 /* minimum value for axis coordinate */
+#define AXIS_MAX 32767  /* maximum value for axis coordinate */
+
+#define MAX_RUMBLE 8
+
+typedef struct joystick_paddata_t
+{
+    u16 prev_buttons;
+    s8 stickX;
+    s8 stickY;
+    s8 substickX;
+    s8 substickY;
+    u8 triggerL;
+    u8 triggerR;
+} joystick_paddata;
+
+typedef struct joystick_wpaddata_t
+{
+    u32 prev_buttons;
+    u32 exp;
+    s16 nunchuk_stickX;
+    s16 nunchuk_stickY;
+    s16 classicL_stickX;
+    s16 classicL_stickY;
+    s16 classicR_stickX;
+    s16 classicR_stickY;
+    u8 classic_triggerL;
+    u8 classic_triggerR;
+    u8 classic_calibrated;
+    s8 wiimote_pitch;
+    s8 wiimote_roll;
+    s8 wiimote_yaw;
+    s16 classic_cal[4][3]; // 4x axes, min/center/max
+} joystick_wpaddata;
+
+/* The private structure used to keep track of a joystick */
+typedef struct joystick_hwdata
+{
+    int index;
+    char sensors_disabled;
+    /*  This must be big enough for MAX_RUMBLE */
+    char rumble_intensity;
+    u16 rumble_loop;
+    union
+    {
+        joystick_paddata gamecube;
+        joystick_wpaddata wiimote;
+    };
+} joystick_hwdata;
+
+#ifdef __wii__
+static const u32 sdl_buttons_wii[] = {
+    WPAD_BUTTON_A | WPAD_CLASSIC_BUTTON_A,
+    WPAD_BUTTON_B | WPAD_CLASSIC_BUTTON_B,
+    WPAD_BUTTON_1,
+    WPAD_BUTTON_2,
+    WPAD_BUTTON_MINUS | WPAD_CLASSIC_BUTTON_MINUS,
+    WPAD_BUTTON_PLUS | WPAD_CLASSIC_BUTTON_PLUS,
+    WPAD_BUTTON_HOME | WPAD_CLASSIC_BUTTON_HOME,
+    WPAD_NUNCHUK_BUTTON_Z, /* 7 */
+    WPAD_NUNCHUK_BUTTON_C, /* 8 */
+    WPAD_CLASSIC_BUTTON_X, /* 9 */
+    WPAD_CLASSIC_BUTTON_Y,
+    WPAD_CLASSIC_BUTTON_FULL_L,
+    WPAD_CLASSIC_BUTTON_FULL_R,
+    WPAD_CLASSIC_BUTTON_ZL,
+    WPAD_CLASSIC_BUTTON_ZR
+};
+#define SDL_WII_NUM_BUTTONS_WII \
+    (sizeof(sdl_buttons_wii) / sizeof(sdl_buttons_wii[0]))
+
+static const u32 sdl_buttons_wiimote[] = {
+    WPAD_BUTTON_A,
+    WPAD_BUTTON_B,
+    WPAD_BUTTON_1,
+    WPAD_BUTTON_2,
+    WPAD_BUTTON_MINUS,
+    WPAD_BUTTON_PLUS,
+    WPAD_BUTTON_HOME,
+};
+#define SDL_WII_NUM_BUTTONS_WIIMOTE \
+    (sizeof(sdl_buttons_wiimote) / sizeof(sdl_buttons_wiimote[0]))
+
+static const u32 sdl_buttons_nunchuck[] = {
+    WPAD_NUNCHUK_BUTTON_Z,
+    WPAD_NUNCHUK_BUTTON_C,
+};
+#define SDL_WII_NUM_BUTTONS_NUNCHUCK \
+    (sizeof(sdl_buttons_nunchuck) / sizeof(sdl_buttons_nunchuck[0]))
+
+static const u32 sdl_buttons_classic[] = {
+    WPAD_CLASSIC_BUTTON_A,
+    WPAD_CLASSIC_BUTTON_B,
+    WPAD_CLASSIC_BUTTON_X,
+    WPAD_CLASSIC_BUTTON_Y,
+    WPAD_CLASSIC_BUTTON_FULL_L,
+    WPAD_CLASSIC_BUTTON_FULL_R,
+    WPAD_CLASSIC_BUTTON_ZL,
+    WPAD_CLASSIC_BUTTON_ZR,
+    WPAD_CLASSIC_BUTTON_MINUS,
+    WPAD_CLASSIC_BUTTON_PLUS,
+    WPAD_CLASSIC_BUTTON_HOME,
+};
+#define SDL_WII_NUM_BUTTONS_CLASSIC \
+    (sizeof(sdl_buttons_classic) / sizeof(sdl_buttons_classic[0]))
+#endif /* __wii__ */
+
+static const u16 sdl_buttons_gc[] = {
+    PAD_BUTTON_A,
+    PAD_BUTTON_B,
+    PAD_BUTTON_X,
+    PAD_BUTTON_Y,
+    PAD_TRIGGER_L,
+    PAD_TRIGGER_R,
+    PAD_TRIGGER_Z,
+    PAD_BUTTON_START,
+};
+
+static int split_joysticks = 0;
+
+static SDL_JoystickID s_connected_instances[MAX_JOYSTICKS];
+/* Value is 0 if controller is not present, otherwise 1 + extension enum */
+static char s_detected_devices[MAX_JOYSTICKS];
+static char s_gc_failed_reads = 0;
+static u32 s_gc_last_scanpads = 0;
+#ifdef __wii__
+static bool s_wii_has_new_data[MAX_WII_JOYSTICKS];
+static bool s_accelerometers_as_axes = false;
+#endif
+static bool s_hardware_queried = false;
+
+/* Joypad index is 0-11: 4 GC, 4 Wiimotes and (if split_joysticks) 4 expansions
+ */
+static int device_index_to_joypad_index(int device_index)
+{
+    int count = 0;
+
+    for (int i = 0; i < MAX_JOYSTICKS; i++) {
+        if (s_connected_instances[i] >= 0) {
+            if (count == device_index)
+                return i;
+            count++;
+        }
+    }
+
+    SDL_LogError(SDL_LOG_CATEGORY_INPUT,
+                 "Cannot find device index %d", device_index);
+    return -1;
+}
+
+static int device_index_to_instance(int device_index)
+{
+    int index = device_index_to_joypad_index(device_index);
+    if (index < 0)
+        return -1;
+    return s_connected_instances[index];
+}
+
+static void scan_hardware(void)
+{
+    /* Scan the GameCube and Wii controllers, but only if this was not done
+     * before during this update cycle.
+     * The Detect() callback, resets the s_hardware_queried variable. */
+    if (!s_hardware_queried) {
+        s_gc_last_scanpads = PAD_ScanPads();
+#ifdef __wii__
+        for (int i = 0; i < MAX_WII_JOYSTICKS; i++) {
+            s_wii_has_new_data[i] = WPAD_ReadPending(i, NULL);
+        }
+#endif
+        s_hardware_queried = true;
+    }
+}
+
+static void report_joystick(int index, int connected)
+{
+    printf("Controller %d was %s (%d)\n",
+           index, connected ? "connected" : "removed", connected);
+
+    /* First, if the joystick was connected with a different expansion, remove
+     * it */
+    if (s_connected_instances[index] >= 0) {
+        SDL_PrivateJoystickRemoved(s_connected_instances[index]);
+        s_connected_instances[index] = -1;
+    }
+
+    if (connected) {
+        s_connected_instances[index] = SDL_GetNextJoystickInstanceID();
+        SDL_PrivateJoystickAdded(s_connected_instances[index]);
+    }
+}
+
+static inline bool enable_rumble(int index, bool enable)
+{
+    if (index >= GC_JOYSTICKS_START && index < GC_JOYSTICKS_END) {
+        PAD_ControlMotor(index - GC_JOYSTICKS_START,
+                         enable ? PAD_MOTOR_RUMBLE : PAD_MOTOR_STOP);
+        return true;
+#ifdef __wii__
+    } else if (index >= WII_WIIMOTES_START && index < WII_JOYSTICKS_END) {
+        WPAD_Rumble(index - WII_WIIMOTES_START, enable);
+        return true;
+#endif
+    } else {
+        return false;
+    }
+}
+
+static void update_rumble(SDL_Joystick *joystick)
+{
+    char intensity = joystick->hwdata->rumble_intensity;
+    s16 loop;
+    int rest_frames;
+    bool rumble;
+    if (intensity == 0 || intensity == MAX_RUMBLE - 1) return;
+
+    loop = ++joystick->hwdata->rumble_loop;
+
+    /* The rest_frames constant should probably be set according to the current
+     * framerate; or we should rework the logic to be completely time-based.
+     * It may also be that we need different values depending on the controller
+     * type. */
+    rest_frames = 2;
+    if (loop == 1) {
+        rumble = false;
+    } else if (loop > (MAX_RUMBLE - 1 - intensity) * rest_frames) {
+        rumble = true;
+        joystick->hwdata->rumble_loop = 0;
+    } else {
+        /* Keep the engine stopped until our time comes again */
+        return;
+    }
+
+    enable_rumble(joystick->hwdata->index, rumble);
+}
+
+static void SDLCALL
+on_hint_accel_as_joystick_cb(void *userdata, const char *name,
+                             const char *oldValue, const char *hint)
+{
+    s_accelerometers_as_axes = SDL_GetStringBoolean(hint, SDL_FALSE);
+}
+
+/* Function to scan the system for joysticks.
+ * This function should return the number of available
+ * joysticks.  Joystick 0 should be the system default joystick.
+ * It should return -1 on an unrecoverable fatal error.
+ */
+static int OGC_JoystickInit(void)
+{
+    const char *split_joystick_env = getenv("SDL_WII_JOYSTICK_SPLIT");
+    split_joysticks = split_joystick_env && strcmp(split_joystick_env, "1") == 0;
+
+    PAD_Init();
+    /* We don't call WPAD_Init() here, since it's already been called by
+     * SDL_main for the Wii */
+
+    SDL_AddHintCallback(SDL_HINT_ACCELEROMETER_AS_JOYSTICK,
+                        on_hint_accel_as_joystick_cb, NULL);
+
+    /* Initialize the needed variables */
+    for (int i = 0; i < MAX_JOYSTICKS; i++) {
+        s_connected_instances[i] = -1;
+    }
+    return 0;
+}
+
+static int OGC_JoystickGetCount(void)
+{
+    int count = 0;
+
+    for (int i = 0; i < MAX_JOYSTICKS; i++) {
+        if (s_connected_instances[i] >= 0)
+            count++;
+    }
+    return count;
+}
+
+static void OGC_JoystickDetect(void)
+{
+    scan_hardware();
+
+    /* Ignore individual disconnected statuses, since they might just
+     * happen because the controller is not ready. */
+    if (s_gc_last_scanpads == 0 && s_gc_failed_reads < 4) {
+        s_gc_failed_reads++;
+        s_hardware_queried = false;
+    } else {
+        s_gc_failed_reads = 0;
+        for (int i = 0; i < MAX_GC_JOYSTICKS; i++) {
+            bool connected = s_gc_last_scanpads & (1 << i);
+            bool was_connected = s_detected_devices[i];
+            if (connected == was_connected)
+                continue;
+
+            report_joystick(i, connected);
+            s_detected_devices[i] = connected;
+        }
+    }
+
+#ifdef __wii__
+    for (int i = 0; i < MAX_WII_JOYSTICKS; i++) {
+        int connected, was_connected, index;
+        WPADData *data;
+
+        if (!s_wii_has_new_data[i])
+            continue;
+
+        data = WPAD_Data(i);
+        index = WII_JOYSTICKS_START + i;
+        connected = data->err != WPAD_ERR_NO_CONTROLLER &&
+                    data->data_present != 0;
+        if (split_joysticks) {
+            int exp_index = WII_EXP_START + i;
+            int exp_connected =
+                (connected && data->exp.type != WPAD_EXP_NONE) ? (1 + data->exp.type) : 0;
+            int exp_was_connected = s_detected_devices[exp_index];
+            if (exp_connected != exp_was_connected) {
+                s_detected_devices[exp_index] = exp_connected;
+                report_joystick(exp_index, exp_connected);
+            }
+        } else if (connected) {
+            connected += data->exp.type;
+        }
+
+        was_connected = s_detected_devices[index];
+        if (connected != was_connected) {
+            s_detected_devices[index] = connected;
+            report_joystick(index, connected);
+        }
+    }
+#endif
+
+    /* This is to force a refresh, the next time that Update() or Detect() are
+     * called. This relies on the fact that SDL calls Detect() after Update().
+     */
+    s_hardware_queried = false;
+}
+
+static char joy_name[128];
+
+/* Function to get the device-dependent name of a joystick */
+static const char *OGC_JoystickGetDeviceName(int device_index)
+{
+    int index = device_index_to_joypad_index(device_index);
+    if (index < 0)
+        return NULL;
+
+    if (index >= GC_JOYSTICKS_START && index < GC_JOYSTICKS_END) {
+        sprintf(joy_name, "Gamecube %d", index);
+#ifdef __wii__
+    } else if (index >= WII_WIIMOTES_START && index < WII_WIIMOTES_END) {
+        char *name_ptr = joy_name;
+        int expansion = s_detected_devices[index] - 1;
+        name_ptr += sprintf(name_ptr, "Wiimote %d", index - WII_WIIMOTES_START);
+        if (!split_joysticks) {
+            // Add expansion information
+            switch (expansion) {
+            case WPAD_EXP_NUNCHUK:
+                strcpy(name_ptr, " + Nunchuk");
+                break;
+            case WPAD_EXP_CLASSIC:
+                strcpy(name_ptr, " + Classic");
+                break;
+            case WPAD_EXP_GUITARHERO3:
+                strcpy(name_ptr, " + Guitar Hero 3");
+                break;
+            case WPAD_EXP_WIIBOARD:
+                strcpy(name_ptr, " + Balance board");
+                break;
+            }
+        }
+    } else if (split_joysticks) {
+        /* This is an expansion and we are using the split controllers
+         * option: show only the expansion name, then. */
+        int expansion = s_detected_devices[index] - 1;
+        int idx = index - WII_EXP_START;
+        switch (expansion) {
+        case WPAD_EXP_NUNCHUK:
+            sprintf(joy_name, "Nunchuk %d", idx);
+            break;
+        case WPAD_EXP_CLASSIC:
+            sprintf(joy_name, "Classic %d", idx);
+            break;
+        case WPAD_EXP_GUITARHERO3:
+            sprintf(joy_name, "Guitar Hero 3 %d", idx);
+            break;
+        case WPAD_EXP_WIIBOARD:
+            sprintf(joy_name, "Balance board %d", idx);
+            break;
+        case WPAD_EXP_NONE:
+            strcpy(joy_name, "Disconnected");
+            break;
+        default:
+            sprintf(joy_name, "Unknown %d", idx);
+            break;
+        }
+#endif
+    } else {
+        sprintf(joy_name, "Invalid device index: %d", device_index);
+    }
+    return joy_name;
+}
+
+static const char *OGC_JoystickGetDevicePath(int index)
+{
+    return NULL;
+}
+
+static int OGC_JoystickGetDevicePlayerIndex(int device_index)
+{
+    return -1;
+}
+
+static void OGC_JoystickSetDevicePlayerIndex(int device_index, int player_index)
+{
+}
+
+static SDL_JoystickGUID OGC_JoystickGetDeviceGUID(int device_index)
+{
+    int index = device_index_to_joypad_index(device_index);
+    Uint16 bus, product, version;
+    Uint8 driver_signature, driver_data;
+    const char *name;
+
+    /* We invent our own product IDs, to tell our joysticks apart.
+     * Since we want the gamepads to appear with the numeric ID in their
+     * name, we make them unique by assigning a different product depending on
+     * the port. */
+    product = index << 8;
+    if (index >= GC_JOYSTICKS_START && index < GC_JOYSTICKS_END) {
+        bus = SDL_HARDWARE_BUS_UNKNOWN;
+    } else {
+        bus = SDL_HARDWARE_BUS_BLUETOOTH;
+        product += s_detected_devices[index];
+    }
+    version = 1;
+    driver_signature = 0;
+    driver_data = 0;
+
+    name = OGC_JoystickGetDeviceName(device_index);
+    return SDL_CreateJoystickGUID(bus, USB_VENDOR_NINTENDO, product, version,
+                                  name, driver_signature, driver_data);
+}
+
+static SDL_JoystickID OGC_JoystickGetDeviceInstanceID(int device_index)
+{
+    return device_index_to_instance(device_index);
+}
+
+static int OGC_JoystickOpen(SDL_Joystick *joystick, int device_index)
+{
+    int index = device_index_to_joypad_index(device_index);
+
+    printf("Open joystick %d (our index: %d)\n", device_index, index);
+
+    if (index < 0)
+        return -1;
+
+    /* allocate memory for system specific hardware data */
+    joystick->hwdata = SDL_malloc(sizeof(joystick_hwdata));
+    if (joystick->hwdata == NULL) {
+        SDL_OutOfMemory();
+        return -1;
+    }
+    joystick->instance_id = s_connected_instances[index];
+
+    SDL_memset(joystick->hwdata, 0, sizeof(joystick_hwdata));
+    joystick->hwdata->index = index;
+    if (index >= GC_JOYSTICKS_START && index < GC_JOYSTICKS_END) {
+        joystick->nbuttons = MAX_GC_BUTTONS;
+        joystick->naxes = MAX_GC_AXES;
+        joystick->nhats = MAX_GC_HATS;
+#ifdef __wii__
+    } else {
+        if (split_joysticks) {
+            if (index < WII_WIIMOTES_END) {
+                // wiimote
+                joystick->nbuttons = SDL_WII_NUM_BUTTONS_WIIMOTE;
+                joystick->naxes = 3;
+                joystick->nhats = 1;
+                SDL_PrivateJoystickAddSensor(joystick, SDL_SENSOR_ACCEL, 100.0f);
+            } else {
+                // expansion
+                joystick->nbuttons = SDL_max(SDL_WII_NUM_BUTTONS_NUNCHUCK,
+                                             SDL_WII_NUM_BUTTONS_CLASSIC);
+                joystick->naxes = 6;
+                joystick->nhats = 1;
+                if (s_detected_devices[index] == 1 + WPAD_EXP_NUNCHUK) {
+                    SDL_PrivateJoystickAddSensor(joystick, SDL_SENSOR_ACCEL_L, 100.0f);
+                }
+            }
+        } else {
+            joystick->nbuttons = MAX_WII_BUTTONS;
+            joystick->naxes = MAX_WII_AXES;
+            joystick->nhats = MAX_WII_HATS;
+            /* Add the accelerometer only if there is no expansion connected */
+            if (s_detected_devices[index] == 1) {
+                SDL_PrivateJoystickAddSensor(joystick, SDL_SENSOR_ACCEL, 100.0f);
+            } else if (s_detected_devices[index] == 1 + WPAD_EXP_NUNCHUK) {
+                /* Or, if the nunchuck is connected, add the wiimote, and the
+                 * nunchuk on the left */
+                SDL_PrivateJoystickAddSensor(joystick, SDL_SENSOR_ACCEL, 100.0f);
+                SDL_PrivateJoystickAddSensor(joystick, SDL_SENSOR_ACCEL_L, 100.0f);
+            }
+        }
+#endif
+    }
+    return 0;
+}
+
+static int OGC_JoystickRumble(SDL_Joystick *joystick,
+                              Uint16 low_frequency_rumble,
+                              Uint16 high_frequency_rumble)
+{
+    int index = joystick->hwdata->index;
+    /* The Wii and GameCube controllers do not support setting the frequency of
+     * the rumble, so we use a hack where we periodically stop and start the
+     * motors during Update(). */
+    char intensity = MAX_RUMBLE *
+        ((low_frequency_rumble + high_frequency_rumble) / 2) /
+        0xffff;
+    /* We don't accept MAX_RUMBLE itself */
+    if (intensity >= MAX_RUMBLE)
+        intensity = MAX_RUMBLE - 1;
+
+    /* If it's the same as the current value, do nothing */
+    if (intensity == joystick->hwdata->rumble_intensity) {
+        return 0;
+    }
+
+    if (!enable_rumble(index, intensity > 0)) {
+        return SDL_Unsupported();
+    }
+
+    /* Save the current rumble status, we need it in update_rumble() */
+    joystick->hwdata->rumble_intensity = intensity;
+    joystick->hwdata->rumble_loop = 0;
+
+    return 0;
+}
+
+static int OGC_JoystickRumbleTriggers(SDL_Joystick *joystick,
+                                      Uint16 left_rumble, Uint16 right_rumble)
+{
+    return SDL_Unsupported();
+}
+
+static Uint32 OGC_JoystickGetCapabilities(SDL_Joystick *joystick)
+{
+    Uint32 capabilities = 0;
+
+    int index = joystick->hwdata->index;
+    if ((index >= GC_JOYSTICKS_START && index < GC_JOYSTICKS_END) ||
+        /* Rumble is supported on the wiimotes, but it makes sense only if no
+         * expansion is attached, of if we are in split mode. */
+        (index >= WII_WIIMOTES_START && index < WII_WIIMOTES_END &&
+         (s_detected_devices[index] == 1 || split_joysticks))) {
+        capabilities |= SDL_JOYCAP_RUMBLE;
+    }
+    return capabilities;
+}
+
+static int OGC_JoystickSetLED(SDL_Joystick *joystick,
+                              Uint8 red, Uint8 green, Uint8 blue)
+{
+    return SDL_Unsupported();
+}
+
+static int OGC_JoystickSendEffect(SDL_Joystick *joystick,
+                                  const void *data, int size)
+{
+    return SDL_Unsupported();
+}
+
+static int OGC_JoystickSetSensorsEnabled(SDL_Joystick *joystick, SDL_bool enabled)
+{
+    int index = joystick->hwdata->index;
+    if (index >= WII_WIIMOTES_START && index < WII_WIIMOTES_END) {
+        joystick->hwdata->sensors_disabled = !enabled;
+        return 0;
+    }
+    return SDL_Unsupported();
+}
+
+#ifdef __wii__
+static s16 WPAD_Orient(WPADData *data, int motion)
+{
+    float out;
+
+    if (motion == 0)
+        out = data->orient.pitch;
+    else if (motion == 1)
+        out = data->orient.roll;
+    else
+        out = data->orient.yaw;
+
+    return (s16)((out / 180.0) * 128.0);
+}
+
+static s16 WPAD_Pitch(WPADData *data)
+{
+    return WPAD_Orient(data, 0);
+}
+
+static s16 WPAD_Roll(WPADData *data)
+{
+    return WPAD_Orient(data, 1);
+}
+
+static s16 WPAD_Yaw(WPADData *data)
+{
+    return WPAD_Orient(data, 2);
+}
+
+static s16 WPAD_Stick(s16 x, s16 min, s16 center, s16 max, int flip)
+{
+    s16 d;
+    int ret;
+
+    x -= center;
+
+    if (x < 0)
+        d = center - min;
+    else
+        d = max - center;
+
+    if (center - min < 5)
+        return 0;
+    if (max - center < 5)
+        return 0;
+
+    if (d)
+        ret = (x << 15) / d;
+    else
+        return 0;
+
+    if (flip)
+        ret = -ret;
+
+    if (ret < AXIS_MIN)
+        ret = AXIS_MIN;
+    else if (ret > AXIS_MAX)
+        ret = AXIS_MAX;
+
+    return ret;
+}
+
+static const u32 _buttons[8] = {
+    // wiimote
+    WPAD_BUTTON_UP,
+    WPAD_BUTTON_DOWN,
+    WPAD_BUTTON_LEFT,
+    WPAD_BUTTON_RIGHT,
+    // classic
+    WPAD_CLASSIC_BUTTON_UP,
+    WPAD_CLASSIC_BUTTON_DOWN,
+    WPAD_CLASSIC_BUTTON_LEFT,
+    WPAD_CLASSIC_BUTTON_RIGHT
+};
+
+static void HandleWiiHats(SDL_Joystick *joystick,
+                          const u32 changed, const u32 pressed,
+                          const u32 *buttons)
+{
+    if (changed & (buttons[0] | buttons[1] | buttons[2] | buttons[3])) {
+        int hat = SDL_HAT_CENTERED;
+
+        if (pressed & buttons[0])
+            hat |= SDL_HAT_UP;
+        if (pressed & buttons[1])
+            hat |= SDL_HAT_DOWN;
+        if (pressed & buttons[2])
+            hat |= SDL_HAT_LEFT;
+        if (pressed & buttons[3])
+            hat |= SDL_HAT_RIGHT;
+        SDL_PrivateJoystickHat(joystick, 0, hat);
+    }
+}
+
+/* Helpers to separate nunchuk vs classic buttons which share the
+ * same scan codes. In particular, up on the classic controller is
+ * the same as Z on the nunchuk. The numbers refer to the sdl_buttons_wii
+ * list above. */
+static int wii_button_is_nunchuk(int idx)
+{
+    return idx == 7 || idx == 8;
+}
+
+static int wii_button_is_classic(int idx)
+{
+    return idx >= 9;
+}
+
+static void HandleWiiButtons(SDL_Joystick *joystick,
+                             const u32 changed,
+                             const WPADData *data,
+                             const u32 *buttons,
+                             size_t num_buttons)
+{
+    for (int i = 0; i < num_buttons; i++) {
+        if (changed & buttons[i]) {
+            if (!split_joysticks &&
+                ((data->exp.type == WPAD_EXP_CLASSIC && wii_button_is_nunchuk(i)) ||
+                 (data->exp.type == WPAD_EXP_NUNCHUK && wii_button_is_classic(i))))
+                continue;
+
+            SDL_PrivateJoystickButton(joystick, i,
+                                      (data->btns_d & buttons[i]) ? SDL_PRESSED : SDL_RELEASED);
+        }
+    }
+}
+
+static void HandleWiiMotion(SDL_Joystick *joystick,
+                            joystick_hwdata *prev_state,
+                            WPADData *data,
+                            int start_index)
+{
+    int axis = WPAD_Pitch(data);
+    if (prev_state->wiimote.wiimote_pitch != axis) {
+        SDL_PrivateJoystickAxis(joystick, start_index, -(axis << 8));
+        prev_state->wiimote.wiimote_pitch = axis;
+    }
+    axis = WPAD_Roll(data);
+    if (prev_state->wiimote.wiimote_roll != axis) {
+        SDL_PrivateJoystickAxis(joystick, start_index + 1, axis << 8);
+        prev_state->wiimote.wiimote_roll = axis;
+    }
+    axis = WPAD_Yaw(data);
+    if (prev_state->wiimote.wiimote_yaw != axis) {
+        SDL_PrivateJoystickAxis(joystick, start_index + 2, axis << 8);
+        prev_state->wiimote.wiimote_yaw = axis;
+    }
+}
+
+static void HandleNunchuckSensors(SDL_Joystick *joystick,
+                                  const nunchuk_t *data)
+{
+    float values[3];
+    SDL_SensorType type;
+
+    if (joystick->hwdata->sensors_disabled) return;
+
+    type = split_joysticks ? SDL_SENSOR_ACCEL : SDL_SENSOR_ACCEL_L;
+    values[0] = data->gforce.x * SDL_STANDARD_GRAVITY;
+    values[1] = data->gforce.z * SDL_STANDARD_GRAVITY;
+    values[2] = -data->gforce.y * SDL_STANDARD_GRAVITY;
+    SDL_PrivateJoystickSensor(joystick, type, 0, values, 3);
+}
+
+static void HandleWiimoteSensors(SDL_Joystick *joystick,
+                                 WPADData *data)
+{
+    float values[3];
+
+    if (joystick->hwdata->sensors_disabled) return;
+
+    values[0] = data->gforce.x * SDL_STANDARD_GRAVITY;
+    values[1] = data->gforce.z * SDL_STANDARD_GRAVITY;
+    values[2] = -data->gforce.y * SDL_STANDARD_GRAVITY;
+    SDL_PrivateJoystickSensor(joystick, SDL_SENSOR_ACCEL, 0, values, 3);
+}
+
+static void _HandleWiiJoystickUpdate(SDL_Joystick *joystick)
+{
+    u32 changed, pressed;
+    int axis, wpad_index;
+    joystick_hwdata *prev_state;
+    WPADData *data;
+    bool update_wiimote, update_expansion;
+
+    prev_state = joystick->hwdata;
+    if (split_joysticks) {
+        if (joystick->hwdata->index >= WII_EXP_START) {
+            wpad_index = joystick->hwdata->index - WII_EXP_START;
+            update_wiimote = false;
+            update_expansion = true;
+        } else {
+            wpad_index = joystick->hwdata->index - WII_WIIMOTES_START;
+            update_wiimote = true;
+            update_expansion = false;
+        }
+    } else {
+        wpad_index = joystick->hwdata->index - WII_WIIMOTES_START;
+        update_wiimote = true;
+        update_expansion = true;
+    }
+
+    if (update_wiimote) {
+        update_rumble(joystick);
+    }
+
+    if (!s_wii_has_new_data[wpad_index])
+        return;
+
+    data = WPAD_Data(wpad_index);
+    changed = data->btns_d | data->btns_u;
+    pressed = data->btns_d | data->btns_h;
+
+    if (update_wiimote) {
+        HandleWiiHats(joystick, changed, pressed, _buttons);
+    }
+    if (update_expansion) {
+        if (data->exp.type == WPAD_EXP_CLASSIC) {
+            HandleWiiHats(joystick, changed, pressed, _buttons + 4);
+        }
+    }
+
+    if (split_joysticks) {
+        if (update_wiimote) {
+            HandleWiiButtons(joystick, changed, data,
+                             sdl_buttons_wiimote, SDL_WII_NUM_BUTTONS_WIIMOTE);
+        }
+        if (update_expansion) {
+            if (data->exp.type == WPAD_EXP_CLASSIC) {
+                HandleWiiButtons(joystick, changed, data,
+                                 sdl_buttons_classic, SDL_WII_NUM_BUTTONS_CLASSIC);
+            } else if (data->exp.type == WPAD_EXP_NUNCHUK) {
+                HandleWiiButtons(joystick, changed, data,
+                                 sdl_buttons_nunchuck, SDL_WII_NUM_BUTTONS_NUNCHUCK);
+            }
+        }
+    } else {
+        HandleWiiButtons(joystick, changed, data,
+                         sdl_buttons_wii, SDL_WII_NUM_BUTTONS_WII);
+    }
+
+    if (update_expansion) {
+        if (data->exp.type == WPAD_EXP_CLASSIC) {
+            if (prev_state->wiimote.exp != WPAD_EXP_CLASSIC) {
+                prev_state->wiimote.classic_calibrated = 0;
+                prev_state->wiimote.classic_cal[0][0] = 5;  // left x min
+                prev_state->wiimote.classic_cal[0][2] = 59; // left x max
+                prev_state->wiimote.classic_cal[1][0] = 5;  // left y min
+                prev_state->wiimote.classic_cal[1][2] = 59; // left y max
+                prev_state->wiimote.classic_cal[2][0] = 5;  // right x min
+                prev_state->wiimote.classic_cal[2][2] = 27; // right x max
+                prev_state->wiimote.classic_cal[3][0] = 5;  // right y min
+                prev_state->wiimote.classic_cal[3][2] = 27; // right y max
+            }
+
+            // max/min checking
+            // left stick x
+            if (data->exp.classic.ljs.pos.x < prev_state->wiimote.classic_cal[0][0])
+                prev_state->wiimote.classic_cal[0][0] = data->exp.classic.ljs.pos.x;
+            else if (data->exp.classic.ljs.pos.x > prev_state->wiimote.classic_cal[0][2])
+                prev_state->wiimote.classic_cal[0][2] = data->exp.classic.ljs.pos.x;
+            // left stick y
+            if (data->exp.classic.ljs.pos.y < prev_state->wiimote.classic_cal[1][0])
+                prev_state->wiimote.classic_cal[1][0] = data->exp.classic.ljs.pos.y;
+            else if (data->exp.classic.ljs.pos.y > prev_state->wiimote.classic_cal[1][2])
+                prev_state->wiimote.classic_cal[1][2] = data->exp.classic.ljs.pos.y;
+            // right stick x
+            if (data->exp.classic.rjs.pos.x < prev_state->wiimote.classic_cal[2][0])
+                prev_state->wiimote.classic_cal[2][0] = data->exp.classic.rjs.pos.x;
+            else if (data->exp.classic.rjs.pos.x > prev_state->wiimote.classic_cal[2][2])
+                prev_state->wiimote.classic_cal[2][2] = data->exp.classic.rjs.pos.x;
+            // right stick y
+            if (data->exp.classic.rjs.pos.y < prev_state->wiimote.classic_cal[3][0])
+                prev_state->wiimote.classic_cal[3][0] = data->exp.classic.rjs.pos.y;
+            else if (data->exp.classic.rjs.pos.y > prev_state->wiimote.classic_cal[3][2])
+                prev_state->wiimote.classic_cal[3][2] = data->exp.classic.rjs.pos.y;
+
+            // calibrate center positions
+            if (prev_state->wiimote.classic_calibrated < 5) {
+                prev_state->wiimote.classic_cal[0][1] = data->exp.classic.ljs.pos.x;
+                prev_state->wiimote.classic_cal[1][1] = data->exp.classic.ljs.pos.y;
+                prev_state->wiimote.classic_cal[2][1] = data->exp.classic.rjs.pos.x;
+                prev_state->wiimote.classic_cal[3][1] = data->exp.classic.rjs.pos.y;
+                // this is zero if the expansion hasn't finished initializing
+                if (data->exp.classic.ljs.max.x)
+                    prev_state->wiimote.classic_calibrated++;
+            }
+        }
+
+        if (data->exp.type != prev_state->wiimote.exp) {
+            // Reset the expansion axes
+            for (int i = 0; i < 6; i++)
+                SDL_PrivateJoystickAxis(joystick, i, 0);
+        }
+
+        if (data->exp.type == WPAD_EXP_CLASSIC) {
+            axis = WPAD_Stick(data->exp.classic.ljs.pos.x, prev_state->wiimote.classic_cal[0][0],
+                              prev_state->wiimote.classic_cal[0][1], prev_state->wiimote.classic_cal[0][2], 0);
+            if (prev_state->wiimote.classicL_stickX != axis) {
+                SDL_PrivateJoystickAxis(joystick, 0, axis);
+                prev_state->wiimote.classicL_stickX = axis;
+            }
+            // y axes are reversed
+            axis = WPAD_Stick(data->exp.classic.ljs.pos.y, prev_state->wiimote.classic_cal[1][0],
+                              prev_state->wiimote.classic_cal[1][1], prev_state->wiimote.classic_cal[1][2], 1);
+            if (prev_state->wiimote.classicL_stickY != axis) {
+                SDL_PrivateJoystickAxis(joystick, 1, axis);
+                prev_state->wiimote.classicL_stickY = axis;
+            }
+            axis = WPAD_Stick(data->exp.classic.rjs.pos.x, prev_state->wiimote.classic_cal[2][0],
+                              prev_state->wiimote.classic_cal[2][1], prev_state->wiimote.classic_cal[2][2], 0);
+            if (prev_state->wiimote.classicR_stickX != axis) {
+                SDL_PrivateJoystickAxis(joystick, 2, axis);
+                prev_state->wiimote.classicR_stickX = axis;
+            }
+            axis = WPAD_Stick(data->exp.classic.rjs.pos.y, prev_state->wiimote.classic_cal[3][0],
+                              prev_state->wiimote.classic_cal[3][1], prev_state->wiimote.classic_cal[3][2], 1);
+            if (prev_state->wiimote.classicR_stickY != axis) {
+                SDL_PrivateJoystickAxis(joystick, 3, axis);
+                prev_state->wiimote.classicR_stickY = axis;
+            }
+            axis = data->exp.classic.r_shoulder;
+            if (prev_state->wiimote.classic_triggerR != axis) {
+                SDL_PrivateJoystickAxis(joystick, 4, axis << 8);
+                prev_state->wiimote.classic_triggerR = axis;
+            }
+            axis = data->exp.classic.l_shoulder;
+            if (prev_state->wiimote.classic_triggerL != axis) {
+                SDL_PrivateJoystickAxis(joystick, 5, axis << 8);
+                prev_state->wiimote.classic_triggerL = axis;
+            }
+        } else if (data->exp.type == WPAD_EXP_NUNCHUK) {
+            axis = WPAD_Stick(data->exp.nunchuk.js.pos.x, data->exp.nunchuk.js.min.x,
+                              data->exp.nunchuk.js.center.x, data->exp.nunchuk.js.max.x, 0);
+            if (prev_state->wiimote.nunchuk_stickX != axis) {
+                SDL_PrivateJoystickAxis(joystick, 0, axis);
+                prev_state->wiimote.nunchuk_stickX = axis;
+            }
+            axis = WPAD_Stick(data->exp.nunchuk.js.pos.y, data->exp.nunchuk.js.min.y,
+                              data->exp.nunchuk.js.center.y, data->exp.nunchuk.js.max.y, 1);
+            if (prev_state->wiimote.nunchuk_stickY != axis) {
+                SDL_PrivateJoystickAxis(joystick, 1, axis);
+                prev_state->wiimote.nunchuk_stickY = axis;
+            }
+
+            HandleNunchuckSensors(joystick, &data->exp.nunchuk);
+        }
+    }
+
+    prev_state->wiimote.exp = data->exp.type;
+
+    if (update_wiimote) {
+        if (s_accelerometers_as_axes) {
+            int start_index = split_joysticks ? 0 : 6;
+            HandleWiiMotion(joystick, prev_state, data, start_index);
+        }
+        HandleWiimoteSensors(joystick, data);
+    }
+}
+#endif /* __wii__ */
+
+static void _HandleGCJoystickUpdate(SDL_Joystick *joystick)
+{
+    u16 buttons, prev_buttons, changed;
+    int i;
+    int axis;
+    joystick_hwdata *prev_state;
+    int index = joystick->hwdata->index - GC_JOYSTICKS_START;
+
+    update_rumble(joystick);
+
+    buttons = PAD_ButtonsHeld(index);
+    prev_state = joystick->hwdata;
+    prev_buttons = prev_state->gamecube.prev_buttons;
+    changed = buttons ^ prev_buttons;
+
+    if (changed & (PAD_BUTTON_LEFT | PAD_BUTTON_RIGHT | PAD_BUTTON_DOWN | PAD_BUTTON_UP)) {
+        int hat = SDL_HAT_CENTERED;
+        if (buttons & PAD_BUTTON_UP)
+            hat |= SDL_HAT_UP;
+        if (buttons & PAD_BUTTON_DOWN)
+            hat |= SDL_HAT_DOWN;
+        if (buttons & PAD_BUTTON_LEFT)
+            hat |= SDL_HAT_LEFT;
+        if (buttons & PAD_BUTTON_RIGHT)
+            hat |= SDL_HAT_RIGHT;
+        SDL_PrivateJoystickHat(joystick, 0, hat);
+    }
+
+    for (i = 0; i < (sizeof(sdl_buttons_gc) / sizeof(sdl_buttons_gc[0])); i++) {
+        if (changed & sdl_buttons_gc[i])
+            SDL_PrivateJoystickButton(joystick, i,
+                                      (buttons & sdl_buttons_gc[i]) ? SDL_PRESSED : SDL_RELEASED);
+    }
+    prev_state->gamecube.prev_buttons = buttons;
+    axis = PAD_StickX(index);
+    if (prev_state->gamecube.stickX != axis) {
+        SDL_PrivateJoystickAxis(joystick, 0, axis << 8);
+        prev_state->gamecube.stickX = axis;
+    }
+
+    axis = PAD_StickY(index);
+    if (prev_state->gamecube.stickY != axis) {
+        SDL_PrivateJoystickAxis(joystick, 1, (-axis) << 8);
+        prev_state->gamecube.stickY = axis;
+    }
+
+    axis = PAD_SubStickX(index);
+    if (prev_state->gamecube.substickX != axis) {
+        SDL_PrivateJoystickAxis(joystick, 2, axis << 8);
+        prev_state->gamecube.substickX = axis;
+    }
+
+    axis = PAD_SubStickY(index);
+    if (prev_state->gamecube.substickY != axis) {
+        SDL_PrivateJoystickAxis(joystick, 3, (-axis) << 8);
+        prev_state->gamecube.substickY = axis;
+    }
+
+    axis = PAD_TriggerL(index);
+    if (prev_state->gamecube.triggerL != axis) {
+        SDL_PrivateJoystickAxis(joystick, 4, axis << 7);
+        prev_state->gamecube.triggerL = axis;
+    }
+
+    axis = PAD_TriggerR(index);
+    if (prev_state->gamecube.triggerR != axis) {
+        SDL_PrivateJoystickAxis(joystick, 5, axis << 7);
+        prev_state->gamecube.triggerR = axis;
+    }
+}
+
+static void OGC_JoystickUpdate(SDL_Joystick *joystick)
+{
+    if (!joystick || !joystick->hwdata)
+        return;
+
+    scan_hardware();
+
+    if (joystick->hwdata->index >= GC_JOYSTICKS_START &&
+        joystick->hwdata->index < GC_JOYSTICKS_END) {
+        _HandleGCJoystickUpdate(joystick);
+#ifdef __wii__
+    } else {
+        _HandleWiiJoystickUpdate(joystick);
+#endif
+    }
+}
+
+static void OGC_JoystickClose(SDL_Joystick *joystick)
+{
+    if (!joystick || !joystick->hwdata) // joystick already closed
+        return;
+
+    SDL_free(joystick->hwdata);
+    joystick->hwdata = NULL;
+}
+
+void OGC_JoystickQuit(void)
+{
+    SDL_DelHintCallback(SDL_HINT_ACCELEROMETER_AS_JOYSTICK,
+                        on_hint_accel_as_joystick_cb, NULL);
+}
+
+static SDL_bool OGC_JoystickGetGamepadMapping(int device_index,
+                                              SDL_GamepadMapping *out)
+{
+    int index = device_index_to_joypad_index(device_index);
+    SDL_bool is_gamepad = SDL_FALSE;
+
+    if (index >= GC_JOYSTICKS_START && index < GC_JOYSTICKS_END) {
+        *out = (SDL_GamepadMapping){
+            .a = { EMappingKind_Button, 0 },
+            .b = { EMappingKind_Button, 2 },
+            .x = { EMappingKind_Button, 1 },
+            .y = { EMappingKind_Button, 3 },
+            .back = { EMappingKind_Button, 6 },
+            .guide = { EMappingKind_None, 255 },
+            .start = { EMappingKind_Button, 7 },
+            .leftstick = { EMappingKind_None, 255 },
+            .rightstick = { EMappingKind_None, 255 },
+            .leftshoulder = { EMappingKind_Button, 4 },
+            .rightshoulder = { EMappingKind_Button, 5 },
+            .dpup = { EMappingKind_Hat, 0x01 },
+            .dpdown = { EMappingKind_Hat, 0x04 },
+            .dpleft = { EMappingKind_Hat, 0x08 },
+            .dpright = { EMappingKind_Hat, 0x02 },
+            .misc1 = { EMappingKind_None, 255 },
+            .paddle1 = { EMappingKind_None, 255 },
+            .paddle2 = { EMappingKind_None, 255 },
+            .paddle3 = { EMappingKind_None, 255 },
+            .paddle4 = { EMappingKind_None, 255 },
+            .leftx = { EMappingKind_Axis, 0 },
+            .lefty = { EMappingKind_Axis, 1 },
+            .rightx = { EMappingKind_Axis, 2 },
+            .righty = { EMappingKind_Axis, 3 },
+            .lefttrigger = { EMappingKind_Axis, 4 },
+            .righttrigger = { EMappingKind_Axis, 5 },
+        };
+        is_gamepad = SDL_TRUE;
+#ifdef __wii__
+    } else if (index >= WII_WIIMOTES_START && index < WII_WIIMOTES_END) {
+        int expansion = s_detected_devices[index] - 1;
+        if (split_joysticks || expansion == 0) {
+            /* Wiimote alone; assume it's being held sideways */
+            *out = (SDL_GamepadMapping){
+                .a = { EMappingKind_Button, 2 },
+                .b = { EMappingKind_Button, 3 },
+                .x = { EMappingKind_Button, 0 },
+                .y = { EMappingKind_Button, 1 },
+                .back = { EMappingKind_Button, 6 },
+                .guide = { EMappingKind_Button, 4 },
+                .start = { EMappingKind_Button, 5 },
+                .leftstick = { EMappingKind_None, 255 },
+                .rightstick = { EMappingKind_None, 255 },
+                .leftshoulder = { EMappingKind_None, 255 },
+                .rightshoulder = { EMappingKind_None, 255 },
+                .dpup = { EMappingKind_Hat, 0x02 },
+                .dpdown = { EMappingKind_Hat, 0x08 },
+                .dpleft = { EMappingKind_Hat, 0x01 },
+                .dpright = { EMappingKind_Hat, 0x04 },
+                .misc1 = { EMappingKind_None, 255 },
+                .paddle1 = { EMappingKind_None, 255 },
+                .paddle2 = { EMappingKind_None, 255 },
+                .paddle3 = { EMappingKind_None, 255 },
+                .paddle4 = { EMappingKind_None, 255 },
+                .leftx = { EMappingKind_Axis, 0 },
+                .lefty = { EMappingKind_Axis, 1 },
+                .rightx = { EMappingKind_None, 255 },
+                .righty = { EMappingKind_None, 255 },
+                .lefttrigger = { EMappingKind_None, 255 },
+                .righttrigger = { EMappingKind_None, 255 },
+            };
+            is_gamepad = SDL_TRUE;
+        } else if (expansion == WPAD_EXP_NUNCHUK) {
+            /* Wiimote with nunchuck; assume nunchuck on left hand, wiimote
+             * pointed at screen */
+            *out = (SDL_GamepadMapping){
+                .a = { EMappingKind_Button, 0 },
+                .b = { EMappingKind_Button, 1 },
+                .x = { EMappingKind_Button, 7 },
+                .y = { EMappingKind_Button, 8 },
+                .back = { EMappingKind_Button, 6 },
+                .guide = { EMappingKind_Button, 4 },
+                .start = { EMappingKind_Button, 5 },
+                .leftstick = { EMappingKind_None, 255 },
+                .rightstick = { EMappingKind_None, 255 },
+                .leftshoulder = { EMappingKind_None, 255 },
+                .rightshoulder = { EMappingKind_None, 255 },
+                .dpup = { EMappingKind_Hat, 0x01 },
+                .dpdown = { EMappingKind_Hat, 0x04 },
+                .dpleft = { EMappingKind_Hat, 0x08 },
+                .dpright = { EMappingKind_Hat, 0x02 },
+                .misc1 = { EMappingKind_None, 255 },
+                .paddle1 = { EMappingKind_None, 255 },
+                .paddle2 = { EMappingKind_None, 255 },
+                .paddle3 = { EMappingKind_None, 255 },
+                .paddle4 = { EMappingKind_None, 255 },
+                .leftx = { EMappingKind_Axis, 0 },
+                .lefty = { EMappingKind_Axis, 1 },
+                .rightx = { EMappingKind_Axis, 2 },
+                .righty = { EMappingKind_Axis, 3 },
+                .lefttrigger = { EMappingKind_None, 255 },
+                .righttrigger = { EMappingKind_None, 255 },
+            };
+            is_gamepad = SDL_TRUE;
+        } else if (expansion == WPAD_EXP_CLASSIC) {
+            *out = (SDL_GamepadMapping){
+                .a = { EMappingKind_Button, 1 },
+                .b = { EMappingKind_Button, 0 },
+                .x = { EMappingKind_Button, 10 },
+                .y = { EMappingKind_Button, 9 },
+                .back = { EMappingKind_Button, 6 },
+                .guide = { EMappingKind_Button, 4 },
+                .start = { EMappingKind_Button, 5 },
+                .leftstick = { EMappingKind_None, 255 },
+                .rightstick = { EMappingKind_None, 255 },
+                .leftshoulder = { EMappingKind_Button, 11 },
+                .rightshoulder = { EMappingKind_Button, 12 },
+                .dpup = { EMappingKind_Hat, 0x01 },
+                .dpdown = { EMappingKind_Hat, 0x04 },
+                .dpleft = { EMappingKind_Hat, 0x08 },
+                .dpright = { EMappingKind_Hat, 0x02 },
+                .misc1 = { EMappingKind_None, 255 },
+                .paddle1 = { EMappingKind_None, 255 },
+                .paddle2 = { EMappingKind_None, 255 },
+                .paddle3 = { EMappingKind_None, 255 },
+                .paddle4 = { EMappingKind_None, 255 },
+                .leftx = { EMappingKind_Axis, 0 },
+                .lefty = { EMappingKind_Axis, 1 },
+                .rightx = { EMappingKind_Axis, 2 },
+                .righty = { EMappingKind_Axis, 3 },
+                .lefttrigger = { EMappingKind_Button, 13 },
+                .righttrigger = { EMappingKind_Button, 14 },
+            };
+            is_gamepad = SDL_TRUE;
+        }
+    } else if (index >= WII_EXP_START && index < WII_EXP_END) {
+        /* Wiimote + Extension: only support the classic controller, any other
+         * device is useless as a gamepad. */
+        int expansion = s_detected_devices[index] - 1;
+        if (expansion != WPAD_EXP_CLASSIC)
+            return SDL_FALSE;
+        *out = (SDL_GamepadMapping){
+            .a = { EMappingKind_Button, 1 },
+            .b = { EMappingKind_Button, 0 },
+            .x = { EMappingKind_Button, 3 },
+            .y = { EMappingKind_Button, 2 },
+            .back = { EMappingKind_Button, 10 },
+            .guide = { EMappingKind_Button, 8 },
+            .start = { EMappingKind_Button, 9 },
+            .leftstick = { EMappingKind_None, 255 },
+            .rightstick = { EMappingKind_None, 255 },
+            .leftshoulder = { EMappingKind_Button, 4 },
+            .rightshoulder = { EMappingKind_Button, 5 },
+            .dpup = { EMappingKind_Hat, 0x01 },
+            .dpdown = { EMappingKind_Hat, 0x04 },
+            .dpleft = { EMappingKind_Hat, 0x08 },
+            .dpright = { EMappingKind_Hat, 0x02 },
+            .misc1 = { EMappingKind_None, 255 },
+            .paddle1 = { EMappingKind_None, 255 },
+            .paddle2 = { EMappingKind_None, 255 },
+            .paddle3 = { EMappingKind_None, 255 },
+            .paddle4 = { EMappingKind_None, 255 },
+            .leftx = { EMappingKind_Axis, 0 },
+            .lefty = { EMappingKind_Axis, 1 },
+            .rightx = { EMappingKind_Axis, 2 },
+            .righty = { EMappingKind_Axis, 3 },
+            .lefttrigger = { EMappingKind_Button, 6 },
+            .righttrigger = { EMappingKind_Button, 7 },
+        };
+        is_gamepad = SDL_TRUE;
+#endif /* __wii__ */
+    }
+    return is_gamepad;
+}
+
+SDL_JoystickDriver SDL_OGC_JoystickDriver = {
+    .Init = OGC_JoystickInit,
+    .GetCount = OGC_JoystickGetCount,
+    .Detect = OGC_JoystickDetect,
+    .GetDeviceName = OGC_JoystickGetDeviceName,
+    .GetDevicePath = OGC_JoystickGetDevicePath,
+    .GetDevicePlayerIndex = OGC_JoystickGetDevicePlayerIndex,
+    .SetDevicePlayerIndex = OGC_JoystickSetDevicePlayerIndex,
+    .GetDeviceGUID = OGC_JoystickGetDeviceGUID,
+    .GetDeviceInstanceID = OGC_JoystickGetDeviceInstanceID,
+    .Open = OGC_JoystickOpen,
+    .Rumble = OGC_JoystickRumble,
+    .RumbleTriggers = OGC_JoystickRumbleTriggers,
+    .GetCapabilities = OGC_JoystickGetCapabilities,
+    .SetLED = OGC_JoystickSetLED,
+    .SendEffect = OGC_JoystickSendEffect,
+    .SetSensorsEnabled = OGC_JoystickSetSensorsEnabled,
+    .Update = OGC_JoystickUpdate,
+    .Close = OGC_JoystickClose,
+    .Quit = OGC_JoystickQuit,
+    .GetGamepadMapping = OGC_JoystickGetGamepadMapping
+};
+
+#endif /* SDL_JOYSTICK_OGC */
+
+/* vi: set sts=4 ts=4 sw=4 expandtab: */
diff --git a/src/main/gamecube/SDL_gamecube_main.c b/src/main/gamecube/SDL_gamecube_main.c
new file mode 100644
index 000000000..f0d42bed9
--- /dev/null
+++ b/src/main/gamecube/SDL_gamecube_main.c
@@ -0,0 +1,54 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#ifdef __gamecube__
+
+#include "SDL_main.h"
+
+#ifdef main
+#undef main
+#endif
+
+/* Standard includes */
+#include <stdio.h>
+
+/* OGC includes */
+#include <fat.h>
+#include <ogcsys.h>
+
+/* Do initialisation which has to be done first for the console to work */
+/* Entry point */
+int main(int argc, char *argv[])
+{
+    //	SYS_SetPowerCallback(ShutdownCB);
+    //	SYS_SetResetCallback(ResetCB);
+    fatInitDefault();
+    /* Temporarily while developing SDL */
+    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);
+    /* Call the user's main function */
+    return (SDL_main(argc, argv));
+}
+
+#endif /* __gamecube__ */
+
+/* vi: set sts=4 ts=4 sw=4 expandtab: */
diff --git a/src/main/wii/SDL_wii_main.c b/src/main/wii/SDL_wii_main.c
new file mode 100644
index 000000000..9a42125aa
--- /dev/null
+++ b/src/main/wii/SDL_wii_main.c
@@ -0,0 +1,91 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#ifdef __wii__
+
+#include "SDL_main.h"
+
+#include "../../video/ogc/SDL_ogcevents_c.h"
+
+#ifdef main
+#undef main
+#endif
+
+/* Standard includes */
+#include <stdio.h>
+
+/* OGC includes */
+#include <fat.h>
+#include <ogc/usbmouse.h>
+#include <ogcsys.h>
+#include <wiikeyboard/keyboard.h>
+#include <wiiuse/wpad.h>
+
+static void ShutdownCB()
+{
+    OGC_PowerOffRequested = true;
+}
+
+static void ResetCB()
+{
+    OGC_ResetRequested = true;
+}
+
+int main(int argc, char *argv[])
+{
+    u32 version;
+    s32 preferred;
+
+    L2Enhance();
+    version = IOS_GetVersion();
+    preferred = IOS_GetPreferredVersion();
+
+    if (preferred > 0 && version != (u32)preferred)
+        IOS_ReloadIOS(preferred);
+
+    // Wii Power/Reset buttons
+    WPAD_Init();
+    WPAD_SetPowerButtonCallback((WPADShutdownCallback)ShutdownCB);
+    SYS_SetPowerCallback(ShutdownCB);
+    SYS_SetResetCallback(ResetCB);
+    // TODO OGC_InitVideoSystem();
+    WPAD_SetDataFormat(WPAD_CHAN_ALL, WPAD_FMT_BTNS_ACC_IR);
+    WPAD_SetVRes(WPAD_CHAN_ALL, 640, 480);
+
+    MOUSE_Init();
+    // TODO KEYBOARD_Init(NULL);
+    fatInitDefault();
+
+    /* Call the user's main function. Make sure that argv contains at least one
+     * element. */
+    if (!argv || argv[0] == NULL) {
+        static const char *dummy_argv[2] = { "app", NULL };
+        argc = 1;
+        argv = (char**)dummy_argv;
+    }
+    return SDL_main(argc, argv);
+}
+
+#endif /* __wii__ */
+
+/* vi: set sts=4 ts=4 sw=4 expandtab: */
diff --git a/src/render/SDL_render.c b/src/render/SDL_render.c
index b650c6ac4..dc7a5b0b2 100644
--- a/src/render/SDL_render.c
+++ b/src/render/SDL_render.c
@@ -124,6 +124,9 @@ static const SDL_RenderDriver *render_drivers[] = {
 #if SDL_VIDEO_RENDER_VITA_GXM
     &VITA_GXM_RenderDriver,
 #endif
+#ifdef SDL_VIDEO_RENDER_OGC
+    &OGC_RenderDriver,
+#endif
 #if SDL_VIDEO_RENDER_SW
     &SW_RenderDriver
 #endif
diff --git a/src/render/SDL_sysrender.h b/src/render/SDL_sysrender.h
index 36e9555bb..d3db2b387 100644
--- a/src/render/SDL_sysrender.h
+++ b/src/render/SDL_sysrender.h
@@ -307,6 +307,7 @@ extern SDL_RenderDriver PS2_RenderDriver;
 extern SDL_RenderDriver PSP_RenderDriver;
 extern SDL_RenderDriver SW_RenderDriver;
 extern SDL_RenderDriver VITA_GXM_RenderDriver;
+extern SDL_RenderDriver OGC_RenderDriver;
 
 /* Blend mode functions */
 extern SDL_BlendFactor SDL_GetBlendModeSrcColorFactor(SDL_BlendMode blendMode);
diff --git a/src/render/ogc/SDL_render_ogc.c b/src/render/ogc/SDL_render_ogc.c
new file mode 100644
index 000000000..96c8de160
--- /dev/null
+++ b/src/render/ogc/SDL_render_ogc.c
@@ -0,0 +1,635 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifdef SDL_VIDEO_RENDER_OGC
+
+#include "../SDL_sysrender.h"
+#include "SDL_hints.h"
+
+#include "../../video/ogc/SDL_ogcgxcommon.h"
+#include "../../video/ogc/SDL_ogcpixels.h"
+#include "../../video/ogc/SDL_ogcvideo.h"
+
+#include <malloc.h>
+#include <ogc/cache.h>
+#include <ogc/gx.h>
+#include <ogc/video.h>
+
+#define MAX_EFB_WIDTH 640
+#define MAX_EFB_HEIGHT 528
+
+typedef struct
+{
+    SDL_BlendMode current_blend_mode;
+    GXColor clear_color;
+    int ops_after_present;
+    bool vsync;
+} OGC_RenderData;
+
+typedef struct
+{
+    void *texels;
+    void *pixels;
+    SDL_Rect pixels_rect;
+    u16 pitch;
+    u16 pixels_pitch;
+    u8 format;
+    u8 needed_stages; // Normally 1, set to 2 for palettized formats
+} OGC_TextureData;
+
+static void OGC_WindowEvent(SDL_Renderer *renderer, const SDL_WindowEvent *event)
+{
+}
+
+static inline void OGC_SetBlendMode(SDL_Renderer *renderer, SDL_BlendMode blend_mode)
+{
+    OGC_RenderData *data = renderer->driverdata;
+
+    if (blend_mode == data->current_blend_mode) {
+        /* Nothing to do */
+        return;
+    }
+
+    switch (blend_mode) {
+    case SDL_BLENDMODE_NONE:
+        GX_SetBlendMode(GX_BM_NONE, GX_BL_SRCALPHA, GX_BL_INVSRCALPHA, GX_LO_CLEAR);
+        break;
+    case SDL_BLENDMODE_BLEND:
+        GX_SetBlendMode(GX_BM_BLEND, GX_BL_SRCALPHA, GX_BL_INVSRCALPHA, GX_LO_CLEAR);
+        break;
+    case SDL_BLENDMODE_ADD:
+        GX_SetBlendMode(GX_BM_BLEND, GX_BL_SRCALPHA, GX_BL_ONE, GX_LO_CLEAR);
+        break;
+    case SDL_BLENDMODE_MOD:
+        GX_SetBlendMode(GX_BM_BLEND, GX_BL_DSTCLR, GX_BL_ZERO, GX_LO_CLEAR);
+        break;
+    case SDL_BLENDMODE_MUL:
+        GX_SetBlendMode(GX_BM_BLEND, GX_BL_DSTCLR, GX_BL_INVSRCALPHA, GX_LO_CLEAR);
+        break;
+    default:
+        return;
+    }
+
+    data->current_blend_mode = blend_mode;
+}
+
+static void save_efb_to_texture(SDL_Renderer *renderer)
+{
+    SDL_Texture *texture = renderer->target;
+    OGC_TextureData *ogc_tex = texture->driverdata;
+
+    GX_SetTexCopySrc(0, 0, texture->w, texture->h);
+    GX_SetTexCopyDst(texture->w, texture->h, ogc_tex->format, GX_FALSE);
+    GX_CopyTex(ogc_tex->texels, GX_TRUE);
+}
+
+static int OGC_CreateTexture(SDL_Renderer *renderer, SDL_Texture *texture)
+{
+    u32 texture_size;
+    OGC_TextureData *ogc_tex;
+
+    ogc_tex = SDL_calloc(1, sizeof(OGC_TextureData));
+    if (!ogc_tex) {
+        return SDL_OutOfMemory();
+    }
+
+    ogc_tex->format = OGC_texture_format_from_SDL(texture->format);
+    ogc_tex->needed_stages = (ogc_tex->format == GX_TF_CI8) ? 2 : 1;
+    texture_size = GX_GetTexBufferSize(texture->w, texture->h, ogc_tex->format,
+                                       GX_FALSE, 0);
+    ogc_tex->texels = memalign(32, texture_size);
+    if (!ogc_tex->texels) {
+        SDL_free(ogc_tex);
+        return SDL_OutOfMemory();
+    }
+
+    texture->driverdata = ogc_tex;
+    return 0;
+}
+
+static int OGC_LockTexture(SDL_Renderer *renderer, SDL_Texture *texture,
+                           const SDL_Rect *rect, void **pixels, int *pitch)
+{
+    OGC_TextureData *ogc_tex = texture->driverdata;
+
+    ogc_tex->pixels = SDL_malloc(rect->w * rect->h * SDL_BYTESPERPIXEL(texture->format));
+    ogc_tex->pixels_pitch = rect->w * SDL_BYTESPERPIXEL(texture->format);
+    ogc_tex->pixels_rect = *rect;
+    *pixels = ogc_tex->pixels;
+    *pitch = ogc_tex->pixels_pitch;
+    return 0;
+}
+
+static void OGC_UnlockTexture(SDL_Renderer *renderer, SDL_Texture *texture)
+{
+    OGC_TextureData *ogc_tex = texture->driverdata;
+    u32 texture_size;
+
+    OGC_pixels_to_texture(ogc_tex->pixels, texture->format,
+                          &ogc_tex->pixels_rect, ogc_tex->pixels_pitch,
+                          ogc_tex->texels, texture->w);
+    /* It would be more effective if we updated only the changed range here,
+     * but the complexity is probably not worth the effort. */
+    texture_size = GX_GetTexBufferSize(texture->w, texture->h, ogc_tex->format,
+                                       GX_FALSE, 0);
+    DCStoreRange(ogc_tex->texels, texture_size);
+    GX_InvalidateTexAll();
+
+
+    if (ogc_tex->pixels) {
+        SDL_free(ogc_tex->pixels);
+        ogc_tex->pixels = NULL;
+    }
+}
+
+static int OGC_UpdateTexture(SDL_Renderer *renderer, SDL_Texture *texture,
+                             const SDL_Rect *rect, const void *pixels, int pitch)
+{
+    OGC_TextureData *ogc_tex = texture->driverdata;
+
+    OGC_pixels_to_texture((void*)pixels, texture->format, rect,
+                          pitch, ogc_tex->texels, texture->w);
+
+    return 0;
+}
+
+static void OGC_SetTextureScaleMode(SDL_Renderer *renderer,
+                                    SDL_Texture *texture,
+                                    SDL_ScaleMode scaleMode)
+{
+    /* Nothing to do here: the scale mode is applied to the texture when
+     * loading it in OGC_load_texture(). */
+}
+
+static int OGC_SetRenderTarget(SDL_Renderer *renderer, SDL_Texture *texture)
+{
+    OGC_RenderData *data = renderer->driverdata;
+
+    if (texture) {
+        if (texture->w > MAX_EFB_WIDTH || texture->h > MAX_EFB_HEIGHT) {
+            return SDL_SetError("Render target bigger than EFB");
+        }
+
+        if (data->ops_after_present > 0) {
+            /* We should save the current EFB contents into the window data.
+             * However, it's unclear whether this is a possible scenario, since
+             * all actual drawing happens in RunCommandQueue() and this method
+             * will not be called in between of the drawing operations; but
+             * just to be on the safe side, log a warning. We can come back to
+             * this later and implement the EFB saving if we see that this
+             * happens in real life.
+             */
+            SDL_LogWarn(SDL_LOG_CATEGORY_RENDER,
+                        "Render target set after drawing!");
+        }
+    }
+    return 0;
+}
+
+static int OGC_QueueSetViewport(SDL_Renderer *renderer, SDL_RenderCommand *cmd)
+{
+    return 0; /* nothing to do in this backend. */
+}
+
+static int OGC_QueueDrawPoints(SDL_Renderer *renderer, SDL_RenderCommand *cmd,
+                               const SDL_FPoint *points, int count)
+{
+    size_t size = count * sizeof(SDL_FPoint);
+    SDL_FPoint *vertices = SDL_AllocateRenderVertices(renderer, size,
+                                                      4, &cmd->data.draw.first);
+    if (!vertices) {
+        return -1;
+    }
+
+    cmd->data.draw.count = count;
+    SDL_memcpy(vertices, points, size);
+    return 0;
+}
+
+static int OGC_QueueFillRects(SDL_Renderer *renderer, SDL_RenderCommand *cmd,
+                               const SDL_FRect *rects, int count)
+{
+    size_t size = count * sizeof(SDL_FPoint) * 4;
+    SDL_FPoint *vertices = SDL_AllocateRenderVertices(renderer, size,
+                                                      4, &cmd->data.draw.first);
+    if (!vertices) {
+        return -1;
+    }
+
+    cmd->data.draw.count = count;
+    for (int i = 0; i < count; i++) {
+        vertices[i].x = rects[i].x;
+        vertices[i].y = rects[i].y;
+        vertices[i+1].x = rects[i].x + rects[i].w;
+        vertices[i+1].y = rects[i].y;
+        vertices[i+2].x = rects[i].x + rects[i].w;
+        vertices[i+2].y = rects[i].y + rects[i].h;
+        vertices[i+3].x = rects[i].x;
+        vertices[i+3].y = rects[i].y + rects[i].h;
+    }
+    return 0;
+}
+
+static int OGC_QueueGeometry(SDL_Renderer *renderer, SDL_RenderCommand *cmd, SDL_Texture *texture,
+                             const float *xy, int xy_stride, const SDL_Color *color, int color_stride,
+                             const float *uv, int uv_stride,
+                             int num_vertices, const void *indices, int num_indices, int size_indices,
+                             float scale_x, float scale_y)
+{
+    int i;
+    int count = indices ? num_indices : num_vertices;
+    size_t size_per_element;
+    char *vertices;
+
+    cmd->data.draw.count = count;
+    size_indices = indices ? size_indices : 0;
+
+    size_per_element = sizeof(SDL_FPoint) + sizeof(SDL_Color);
+    if (texture) {
+        size_per_element += sizeof(SDL_FPoint);
+    }
+
+    vertices = SDL_AllocateRenderVertices(renderer, count * size_per_element,
+                                          4, &cmd->data.draw.first);
+    if (!vertices) {
+        return -1;
+    }
+
+    for (i = 0; i < count; i++) {
+        int j;
+        float *xy_;
+        float *uv_;
+        SDL_Color col;
+        char *vertex;
+        SDL_FPoint *vertex_xy;
+        if (size_indices == 4) {
+            j = ((const Uint32 *)indices)[i];
+        } else if (size_indices == 2) {
+            j = ((const Uint16 *)indices)[i];
+        } else if (size_indices == 1) {
+            j = ((const Uint8 *)indices)[i];
+        } else {
+            j = i;
+        }
+
+        xy_ = (float *)((char *)xy + j * xy_stride);
+        col = *(SDL_Color *)((char *)color + j * color_stride);
+        uv_ = (float *)((char *)uv + j * uv_stride);
+
+        vertex = vertices + size_per_element * i;
+
+        vertex_xy = (SDL_FPoint *)vertex;
+        vertex_xy->x = xy_[0];
+        vertex_xy->y = xy_[1];
+
+        *(SDL_Color *)(vertex + sizeof(SDL_FPoint)) = col;
+
+        if (texture) {
+            SDL_FPoint *vertex_uv = (SDL_FPoint *)(vertex + sizeof(SDL_FPoint) + sizeof(SDL_Color));
+            vertex_uv->x = uv_[0];
+            vertex_uv->y = uv_[1];
+        }
+    }
+
+    return 0;
+}
+
+static int OGC_RenderSetViewPort(SDL_Renderer *renderer, SDL_RenderCommand *cmd)
+{
+    const SDL_Rect *viewport = &cmd->data.viewport.rect;
+
+    float v_aspect = viewport->h / 2.0;
+    float h_aspect = viewport->w / 2.0;
+    OGC_set_viewport(viewport->x, viewport->y, viewport->w, viewport->h,
+                     h_aspect, v_aspect);
+    return 0;
+}
+
+static int OGC_RenderSetClipRect(SDL_Renderer *renderer, SDL_RenderCommand *cmd)
+{
+    const SDL_Rect *rect = &cmd->data.cliprect.rect;
+
+    if (cmd->data.cliprect.enabled) {
+        GX_SetScissor(renderer->viewport.x + rect->x,
+                      renderer->viewport.y + rect->y,
+                      rect->w, rect->h);
+        GX_SetClipMode(GX_CLIP_ENABLE);
+    } else {
+        GX_SetClipMode(GX_CLIP_DISABLE);
+    }
+
+    return 0;
+}
+
+static int OGC_RenderClear(SDL_Renderer *renderer, SDL_RenderCommand *cmd)
+{
+    OGC_RenderData *data = renderer->driverdata;
+
+    GXColor c = {
+        cmd->data.color.r,
+        cmd->data.color.g,
+        cmd->data.color.b,
+        cmd->data.color.a
+    };
+
+    /* If nothing has been drawn after Present, and if the clear color has not
+     * changed, there's no need to do anything here. */
+    if (data->ops_after_present == 0 &&
+        GX_COLOR_AS_U32(c) == GX_COLOR_AS_U32(data->clear_color)) {
+        return 0;
+    }
+
+    data->clear_color = c;
+    GX_SetCopyClear(c, GX_MAX_Z24);
+    GX_CopyDisp(OGC_video_get_xfb(SDL_GetVideoDevice()), GX_TRUE);
+
+    return 0;
+}
+
+static int OGC_RenderGeometry(SDL_Renderer *renderer, void *vertices,
+                              SDL_RenderCommand *cmd)
+{
+    OGC_RenderData *data = renderer->driverdata;
+    const size_t count = cmd->data.draw.count;
+    SDL_Texture *texture = cmd->data.draw.texture;
+    size_t size_per_element;
+
+    data->ops_after_present++;
+    OGC_SetBlendMode(renderer, cmd->data.draw.blend);
+
+    size_per_element = sizeof(SDL_FPoint) + sizeof(SDL_Color);
+
+    GX_ClearVtxDesc();
+    GX_SetVtxDesc(GX_VA_POS, GX_DIRECT);
+    GX_SetVtxDesc(GX_VA_CLR0, GX_DIRECT);
+    GX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XY, GX_F32, 0);
+    GX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_CLR0, GX_CLR_RGBA, GX_RGBA8, 0);
+    if (texture) {
+        OGC_TextureData *ogc_tex = texture->driverdata;
+        u8 stage;
+
+        size_per_element += sizeof(SDL_FPoint);
+        OGC_load_texture(ogc_tex->texels, texture->w, texture->h,
+                         ogc_tex->format, texture->scaleMode);
+        stage = GX_TEVSTAGE0 + ogc_tex->needed_stages - 1;
+
+        GX_SetVtxDesc(GX_VA_TEX0, GX_DIRECT);
+        GX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_F32, 0);
+        GX_SetNumTexGens(1);
+
+        GX_SetTexCoordGen(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY);
+        GX_SetTevOrder(stage, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR0A0);
+        GX_SetTevOp(stage, GX_MODULATE);
+        GX_SetNumTevStages(stage - GX_TEVSTAGE0 + 1);
+    } else {
+        GX_SetTevOp(GX_TEVSTAGE0, GX_PASSCLR);
+    }
+
+    GX_Begin(GX_TRIANGLES, GX_VTXFMT0, count);
+    for (int i = 0; i < count; i++) {
+        void *vertex = vertices + cmd->data.draw.first + size_per_element * i;
+        SDL_FPoint *vertex_xy = vertex;
+        SDL_Color *c = (SDL_Color*)(vertex + sizeof(SDL_FPoint));
+
+        GX_Position2f32(vertex_xy->x, vertex_xy->y);
+        GX_Color4u8(c->r, c->g, c->b, c->a);
+        if (texture) {
+            SDL_FPoint *vertex_uv = (SDL_FPoint *)(vertex + sizeof(SDL_FPoint) + sizeof(SDL_Color));
+            GX_TexCoord2f32(vertex_uv->x, vertex_uv->y);
+        }
+    }
+    GX_End();
+    return 0;
+}
+
+int OGC_RenderPrimitive(SDL_Renderer *renderer, u8 primitive,
+                        void *vertices, SDL_RenderCommand *cmd)
+{
+    OGC_RenderData *data = renderer->driverdata;
+    size_t count = cmd->data.draw.count;
+    const SDL_FPoint *verts = (SDL_FPoint *)(vertices + cmd->data.draw.first);
+    GXColor c = {
+        cmd->data.draw.r,
+        cmd->data.draw.g,
+        cmd->data.draw.b,
+        cmd->data.draw.a
+    };
+
+    data->ops_after_present++;
+    OGC_SetBlendMode(renderer, cmd->data.draw.blend);
+
+    /* TODO: optimize state changes. */
+    GX_SetTevColor(GX_TEVREG0, c);
+    GX_SetTevColorIn(GX_TEVSTAGE0, GX_CC_C0, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO);
+    GX_SetTevAlphaIn(GX_TEVSTAGE0, GX_CA_A0, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO);
+    GX_SetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
+    GX_SetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
+
+    GX_ClearVtxDesc();
+    GX_SetVtxDesc(GX_VA_POS, GX_DIRECT);
+    GX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XY, GX_F32, 0);
+
+    if (primitive == GX_QUADS) count *= 4;
+
+    GX_Begin(primitive, GX_VTXFMT0, count);
+    for (int i = 0; i < count; i++) {
+        GX_Position2f32(verts[i].x, verts[i].y);
+    }
+    GX_End();
+
+    /* The last point is not drawn */
+    if (primitive == GX_LINESTRIP) {
+        GX_Begin(GX_POINTS, GX_VTXFMT0, 1);
+        GX_Position2f32(verts[count - 1].x, verts[count - 1].y);
+        GX_End();
+    }
+
+    return 0;
+}
+
+static int OGC_RunCommandQueue(SDL_Renderer *renderer, SDL_RenderCommand *cmd, void *vertices, size_t vertsize)
+{
+    while (cmd) {
+        switch (cmd->command) {
+        case SDL_RENDERCMD_SETVIEWPORT:
+            OGC_RenderSetViewPort(renderer, cmd);
+            break;
+        case SDL_RENDERCMD_SETCLIPRECT:
+            OGC_RenderSetClipRect(renderer, cmd);
+            break;
+        case SDL_RENDERCMD_SETDRAWCOLOR:
+            /* This is a no-op, since every command carries the color, and
+             * setting it on the FIFO is not expensive. */
+            break;
+        case SDL_RENDERCMD_CLEAR:
+            OGC_RenderClear(renderer, cmd);
+            break;
+        case SDL_RENDERCMD_DRAW_POINTS:
+            OGC_RenderPrimitive(renderer, GX_POINTS, vertices, cmd);
+            break;
+        case SDL_RENDERCMD_DRAW_LINES:
+            OGC_RenderPrimitive(renderer, GX_LINESTRIP, vertices, cmd);
+            break;
+        case SDL_RENDERCMD_FILL_RECTS:
+            OGC_RenderPrimitive(renderer, GX_QUADS, vertices, cmd);
+            break;
+        case SDL_RENDERCMD_COPY: /* unused */
+            break;
+        case SDL_RENDERCMD_COPY_EX: /* unused */
+            break;
+        case SDL_RENDERCMD_GEOMETRY:
+            OGC_RenderGeometry(renderer, vertices, cmd);
+            break;
+        case SDL_RENDERCMD_NO_OP:
+            break;
+        }
+        cmd = cmd->next;
+    }
+
+    if (renderer->target) {
+        save_efb_to_texture(renderer);
+    }
+
+    return 0;
+}
+
+static int OGC_RenderReadPixels(SDL_Renderer *renderer, const SDL_Rect *rect,
+                                Uint32 format, void *pixels, int pitch)
+{
+    return SDL_Unsupported();
+}
+
+static int OGC_RenderPresent(SDL_Renderer *renderer)
+{
+    OGC_RenderData *data = renderer->driverdata;
+
+    GX_DrawDone();
+
+    OGC_video_flip(SDL_GetVideoDevice(), data->vsync);
+
+    data->ops_after_present = 0;
+    return 0;
+}
+
+static void OGC_DestroyTexture(SDL_Renderer *renderer, SDL_Texture *texture)
+{
+    OGC_TextureData *ogc_tex = texture->driverdata;
+
+    if (ogc_tex) {
+        free(ogc_tex->texels);
+        SDL_free(ogc_tex);
+        texture->driverdata = NULL;
+    }
+}
+
+static void OGC_DestroyRenderer(SDL_Renderer *renderer)
+{
+    OGC_RenderData *data = renderer->driverdata;
+
+    if (data) {
+        SDL_free(data);
+    }
+
+    SDL_free(renderer);
+}
+
+static int OGC_SetVSync(SDL_Renderer *renderer, const int vsync)
+{
+    OGC_RenderData *data = (OGC_RenderData *)renderer->driverdata;
+    data->vsync = vsync ? 1 : 0;
+    return 0;
+}
+
+static SDL_Renderer *OGC_CreateRenderer(SDL_Window *window, Uint32 flags)
+{
+    SDL_Renderer *renderer;
+    OGC_RenderData *data;
+
+    renderer = (SDL_Renderer *)SDL_calloc(1, sizeof(*renderer));
+    if (!renderer) {
+        SDL_OutOfMemory();
+        return NULL;
+    }
+
+    data = (OGC_RenderData *)SDL_calloc(1, sizeof(*data));
+    if (!data) {
+        OGC_DestroyRenderer(renderer);
+        SDL_OutOfMemory();
+        return NULL;
+    }
+
+    data->current_blend_mode = SDL_BLENDMODE_NONE;
+    data->vsync = true;
+
+    renderer->WindowEvent = OGC_WindowEvent;
+    renderer->CreateTexture = OGC_CreateTexture;
+    renderer->UpdateTexture = OGC_UpdateTexture;
+    renderer->LockTexture = OGC_LockTexture;
+    renderer->UnlockTexture = OGC_UnlockTexture;
+    renderer->SetTextureScaleMode = OGC_SetTextureScaleMode;
+    renderer->SetRenderTarget = OGC_SetRenderTarget;
+    renderer->QueueSetViewport = OGC_QueueSetViewport;
+    renderer->QueueSetDrawColor = OGC_QueueSetViewport;
+    renderer->QueueDrawPoints = OGC_QueueDrawPoints;
+    renderer->QueueDrawLines = OGC_QueueDrawPoints;
+    renderer->QueueFillRects = OGC_QueueFillRects;
+    renderer->QueueGeometry = OGC_QueueGeometry;
+    renderer->RunCommandQueue = OGC_RunCommandQueue;
+    renderer->RenderReadPixels = OGC_RenderReadPixels;
+    renderer->RenderPresent = OGC_RenderPresent;
+    renderer->DestroyTexture = OGC_DestroyTexture;
+    renderer->DestroyRenderer = OGC_DestroyRenderer;
+    renderer->SetVSync = OGC_SetVSync;
+    renderer->info = OGC_RenderDriver.info;
+    renderer->driverdata = data;
+    renderer->window = window;
+
+    if (!SDL_GetHint(SDL_HINT_RENDER_LINE_METHOD)) {
+        /* SDL sets the default one to point drawing, but we prefer lines */
+        SDL_SetHint(SDL_HINT_RENDER_LINE_METHOD, "2");
+    }
+
+    return renderer;
+}
+
+SDL_RenderDriver OGC_RenderDriver = {
+    .CreateRenderer = OGC_CreateRenderer,
+    .info = {
+        .name = "ogc",
+        .flags = SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC | SDL_RENDERER_TARGETTEXTURE,
+        .num_texture_formats = 5,
+        .texture_formats = {
+            [0] = SDL_PIXELFORMAT_RGB565,
+            [1] = SDL_PIXELFORMAT_RGBA8888,
+            [2] = SDL_PIXELFORMAT_ARGB8888,
+            [3] = SDL_PIXELFORMAT_RGB24,
+            [4] = SDL_PIXELFORMAT_XRGB8888,
+            // TODO: add more
+        },
+        .max_texture_width = 1024,
+        .max_texture_height = 1024,
+    }
+};
+
+#endif /* SDL_VIDEO_RENDER_OGC */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/SDL_thread_c.h b/src/thread/SDL_thread_c.h
index 278a68026..f2791f1ff 100644
--- a/src/thread/SDL_thread_c.h
+++ b/src/thread/SDL_thread_c.h
@@ -32,7 +32,9 @@
 #include "pthread/SDL_systhread_c.h"
 #elif SDL_THREAD_WINDOWS
 #include "windows/SDL_systhread_c.h"
-#elif SDL_THREAD_PS2
+#elif defined(SDL_THREAD_OGC)
+#include "ogc/SDL_systhread_c.h"
+#elif defined(SDL_THREAD_PS2)
 #include "ps2/SDL_systhread_c.h"
 #elif SDL_THREAD_PSP
 #include "psp/SDL_systhread_c.h"
diff --git a/src/thread/ogc/SDL_syscond.c b/src/thread/ogc/SDL_syscond.c
new file mode 100644
index 000000000..352fd7bf6
--- /dev/null
+++ b/src/thread/ogc/SDL_syscond.c
@@ -0,0 +1,131 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* An implementation of condition variables using semaphores and mutexes */
+/*
+   This implementation borrows heavily from the BeOS condition variable
+   implementation, written by Christopher Tate and Owen Smith.  Thanks!
+ */
+
+#include "SDL_thread.h"
+#include "SDL_sysmutex_c.h"
+
+#include <ogcsys.h>
+#include <ogc/cond.h>
+
+struct SDL_cond
+{
+    cond_t cond;
+};
+
+/* Create a condition variable */
+SDL_cond * SDL_CreateCond(void)
+{
+    SDL_cond *cond;
+
+    cond = (SDL_cond *) SDL_malloc(sizeof(SDL_cond));
+    if (cond) {
+        if (LWP_CondInit(&(cond->cond)) < 0) {
+            SDL_DestroyCond(cond);
+            cond = NULL;
+        }
+    } else {
+        SDL_OutOfMemory();
+    }
+    return (cond);
+}
+
+/* Destroy a condition variable */
+void SDL_DestroyCond(SDL_cond *cond)
+{
+    if (cond) {
+        LWP_CondDestroy(cond->cond);
+        SDL_free(cond);
+    }
+}
+
+/* Restart one of the threads that are waiting on the condition variable */
+int SDL_CondSignal(SDL_cond *cond)
+{
+    if (!cond) {
+        SDL_SetError("Passed a NULL condition variable");
+        return -1;
+    }
+
+    return LWP_CondSignal(cond->cond) == 0 ? 0 : -1;
+
+}
+
+/* Restart all threads that are waiting on the condition variable */
+int SDL_CondBroadcast(SDL_cond *cond)
+{
+    if (!cond) {
+        SDL_SetError("Passed a NULL condition variable");
+        return -1;
+    }
+
+    return LWP_CondBroadcast(cond->cond) == 0 ? 0 : -1;
+}
+
+/* Wait on the condition variable for at most 'ms' milliseconds.
+ The mutex must be locked before entering this function!
+ The mutex is unlocked during the wait, and locked again after the wait.
+
+ Typical use:
+
+ Thread A:
+ SDL_LockMutex(lock);
+ while ( ! condition ) {
+ SDL_CondWait(cond);
+ }
+ SDL_UnlockMutex(lock);
+
+ Thread B:
+ SDL_LockMutex(lock);
+ ...
+ condition = true;
+ ...
+ SDL_UnlockMutex(lock);
+ */
+
+
+int SDL_CondWaitTimeout(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms)
+{
+    struct timespec time;
+
+    if (!cond) {
+        SDL_SetError("Passed a NULL condition variable");
+        return -1;
+    }
+    //LWP_CondTimedWait expects relative timeout
+    time.tv_sec = (ms / 1000);
+    time.tv_nsec = (ms % 1000) * 1000000;
+
+    return LWP_CondTimedWait(cond->cond, mutex->id, &time);
+}
+
+/* Wait on the condition variable forever */
+int SDL_CondWait(SDL_cond *cond, SDL_mutex *mutex)
+{
+    return LWP_CondWait(cond->cond, mutex->id);
+}
diff --git a/src/thread/ogc/SDL_sysmutex.c b/src/thread/ogc/SDL_sysmutex.c
new file mode 100644
index 000000000..210fef09b
--- /dev/null
+++ b/src/thread/ogc/SDL_sysmutex.c
@@ -0,0 +1,81 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* An implementation of mutexes using semaphores */
+
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+#include <ogcsys.h>
+
+struct SDL_mutex
+{
+    u32 id;
+};
+
+/* Create a mutex */
+SDL_mutex *SDL_CreateMutex(void)
+{
+    SDL_mutex *mutex = NULL;
+
+    /* Allocate mutex memory */
+    mutex = (SDL_mutex *) SDL_malloc(sizeof(*mutex));
+    if (mutex) {
+        LWP_MutexInit(&mutex->id, 0);
+    } else {
+        SDL_OutOfMemory();
+    }
+    return mutex;
+}
+
+/* Free the mutex */
+void SDL_DestroyMutex(SDL_mutex *mutex)
+{
+    if (mutex) {
+        LWP_MutexDestroy(mutex->id);
+        SDL_free(mutex);
+    }
+}
+
+/* Lock the semaphore */
+int SDL_mutexP(SDL_mutex *mutex)
+{
+    if (mutex == NULL) {
+        SDL_SetError("Passed a NULL mutex");
+        return -1;
+    }
+
+    return LWP_MutexLock(mutex->id);
+}
+
+/* Unlock the mutex */
+int SDL_mutexV(SDL_mutex *mutex)
+{
+    if (mutex == NULL) {
+        SDL_SetError("Passed a NULL mutex");
+        return -1;
+    }
+
+    return LWP_MutexUnlock(mutex->id);
+
+}
diff --git a/src/thread/ogc/SDL_sysmutex_c.h b/src/thread/ogc/SDL_sysmutex_c.h
new file mode 100644
index 000000000..fe692acc0
--- /dev/null
+++ b/src/thread/ogc/SDL_sysmutex_c.h
@@ -0,0 +1,26 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+struct SDL_mutex {
+    Uint32 id;
+};
diff --git a/src/thread/ogc/SDL_syssem.c b/src/thread/ogc/SDL_syssem.c
new file mode 100644
index 000000000..825de911f
--- /dev/null
+++ b/src/thread/ogc/SDL_syssem.c
@@ -0,0 +1,162 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* An implementation of semaphores using mutexes and condition variables */
+
+#include "SDL_timer.h"
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+struct SDL_semaphore
+{
+    Uint32 count;
+    Uint32 waiters_count;
+    SDL_mutex *count_lock;
+    SDL_cond *count_nonzero;
+};
+
+SDL_sem *SDL_CreateSemaphore(Uint32 initial_value)
+{
+    SDL_sem *sem;
+
+    sem = (SDL_sem *) SDL_malloc(sizeof(*sem));
+    if (!sem) {
+        SDL_OutOfMemory();
+        return NULL;
+    }
+    sem->count = initial_value;
+    sem->waiters_count = 0;
+
+    sem->count_lock = SDL_CreateMutex();
+    sem->count_nonzero = SDL_CreateCond();
+    if (!sem->count_lock || !sem->count_nonzero) {
+        SDL_DestroySemaphore(sem);
+        return NULL;
+    }
+
+    return sem;
+}
+
+/* WARNING:
+ You cannot call this function when another thread is using the semaphore.
+ */
+void SDL_DestroySemaphore(SDL_sem *sem)
+{
+    if (sem) {
+        sem->count = 0xFFFFFFFF;
+        while (sem->waiters_count > 0) {
+            SDL_CondSignal(sem->count_nonzero);
+            SDL_Delay(10);
+        }
+        SDL_DestroyCond(sem->count_nonzero);
+        if (sem->count_lock) {
+            SDL_mutexP(sem->count_lock);
+            SDL_mutexV(sem->count_lock);
+            SDL_DestroyMutex(sem->count_lock);
+        }
+        SDL_free(sem);
+    }
+}
+
+int SDL_SemTryWait(SDL_sem *sem)
+{
+    int retval;
+
+    if (!sem) {
+        SDL_SetError("Passed a NULL semaphore");
+        return -1;
+    }
+
+    retval = SDL_MUTEX_TIMEDOUT;
+    SDL_LockMutex(sem->count_lock);
+    if (sem->count > 0) {
+        --sem->count;
+        retval = 0;
+    }
+    SDL_UnlockMutex(sem->count_lock);
+
+    return retval;
+}
+
+int SDL_SemWaitTimeout(SDL_sem *sem, Uint32 timeout)
+{
+    int retval;
+
+    if (!sem) {
+        SDL_SetError("Passed a NULL semaphore");
+        return -1;
+    }
+
+    /* A timeout of 0 is an easy case */
+    if (timeout == 0) {
+        return SDL_SemTryWait(sem);
+    }
+
+    SDL_LockMutex(sem->count_lock);
+    ++sem->waiters_count;
+    retval = 0;
+    while ((sem->count == 0) && (retval != SDL_MUTEX_TIMEDOUT)) {
+        retval = SDL_CondWaitTimeout(sem->count_nonzero, sem->count_lock,
+                timeout);
+    }
+    --sem->waiters_count;
+    --sem->count;
+    SDL_UnlockMutex(sem->count_lock);
+
+    return retval;
+}
+
+int SDL_SemWait(SDL_sem *sem)
+{
+    return SDL_SemWaitTimeout(sem, SDL_MUTEX_MAXWAIT);
+}
+
+Uint32 SDL_SemValue(SDL_sem *sem)
+{
+    Uint32 value;
+
+    value = 0;
+    if (sem) {
+        SDL_LockMutex(sem->count_lock);
+        value = sem->count;
+        SDL_UnlockMutex(sem->count_lock);
+    }
+    return value;
+}
+
+int SDL_SemPost(SDL_sem *sem)
+{
+    if (!sem) {
+        SDL_SetError("Passed a NULL semaphore");
+        return -1;
+    }
+
+    SDL_LockMutex(sem->count_lock);
+    if (sem->waiters_count > 0) {
+        SDL_CondSignal(sem->count_nonzero);
+    }
+    ++sem->count;
+    SDL_UnlockMutex(sem->count_lock);
+
+    return 0;
+}
diff --git a/src/thread/ogc/SDL_systhread.c b/src/thread/ogc/SDL_systhread.c
new file mode 100644
index 000000000..3bc96af47
--- /dev/null
+++ b/src/thread/ogc/SDL_systhread.c
@@ -0,0 +1,86 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* Thread management routines for SDL */
+
+#include "SDL_thread.h"
+#include "../SDL_systhread.h"
+#include "../SDL_thread_c.h"
+
+#include <ogcsys.h>
+
+void *run_thread(void *data)
+{
+    SDL_RunThread(data);
+    return (void *) 0; /* Prevent compiler warning */
+}
+
+int SDL_SYS_CreateThread(SDL_Thread *thread)
+{
+    if (LWP_CreateThread(&thread->handle, run_thread,
+                         thread, 0, 0, 64) != 0 ) {
+        SDL_SetError("Not enough resources to create thread");
+        return -1;
+    }
+
+    return 0;
+}
+
+void SDL_SYS_SetupThread(const char *name)
+{
+}
+
+int SDL_SYS_SetThreadPriority(SDL_ThreadPriority priority)
+{
+    u8 value;
+
+    /* Range is 0 (lowest) to 127 (highest) */
+    if (priority == SDL_THREAD_PRIORITY_LOW) {
+        value = 0;
+    } else if (priority == SDL_THREAD_PRIORITY_HIGH) {
+        value = 80;
+    } else if (priority == SDL_THREAD_PRIORITY_TIME_CRITICAL) {
+        value = 127;
+    } else {
+        value = 64;
+    }
+    LWP_SetThreadPriority(LWP_THREAD_NULL, value);
+    return 0;
+}
+
+SDL_threadID SDL_ThreadID(void)
+{
+    return (SDL_threadID)LWP_GetSelf();
+}
+
+void SDL_SYS_WaitThread(SDL_Thread *thread)
+{
+    void *v;
+    LWP_JoinThread(thread->handle, &v);
+    return;
+}
+
+void SDL_SYS_KillThread(SDL_Thread *thread)
+{
+    return;
+}
diff --git a/src/thread/ogc/SDL_systhread_c.h b/src/thread/ogc/SDL_systhread_c.h
new file mode 100644
index 000000000..43caca7eb
--- /dev/null
+++ b/src/thread/ogc/SDL_systhread_c.h
@@ -0,0 +1,24 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+typedef Uint32 SYS_ThreadHandle;
diff --git a/src/timer/ogc/SDL_systimer.c b/src/timer/ogc/SDL_systimer.c
new file mode 100644
index 000000000..83a946d56
--- /dev/null
+++ b/src/timer/ogc/SDL_systimer.c
@@ -0,0 +1,76 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#ifdef SDL_TIMER_OGC
+
+#include <ogc/lwp_watchdog.h>
+#include <ogcsys.h>
+
+static SDL_bool ticks_started = SDL_FALSE;
+static u64 start;
+
+void SDL_TicksInit(void)
+{
+    if (ticks_started) {
+        return;
+    }
+    ticks_started = SDL_TRUE;
+
+    start = gettime();
+}
+
+void SDL_TicksQuit(void)
+{
+    ticks_started = SDL_FALSE;
+}
+
+Uint64 SDL_GetTicks64(void)
+{
+    const u64 ticks = gettime() - start;
+    const u64 ms = ticks / TB_TIMER_CLOCK;
+    return ms;
+}
+
+Uint64 SDL_GetPerformanceCounter(void)
+{
+    return SDL_GetTicks64();
+}
+
+Uint64 SDL_GetPerformanceFrequency(void)
+{
+    return 1000;
+}
+
+void SDL_Delay(Uint32 ms)
+{
+    struct timespec elapsed, tv;
+    elapsed.tv_sec = ms / 1000;
+    elapsed.tv_nsec = (ms % 1000) * 1000000;
+    tv.tv_sec = elapsed.tv_sec;
+    tv.tv_nsec = elapsed.tv_nsec;
+    nanosleep(&tv, &elapsed);
+}
+
+#endif /* SDL_TIMER_OGC */
+
+/* vi: set sts=4 ts=4 sw=4 expandtab: */
diff --git a/src/video/SDL_sysvideo.h b/src/video/SDL_sysvideo.h
index d7a42cc64..db2cb54c8 100644
--- a/src/video/SDL_sysvideo.h
+++ b/src/video/SDL_sysvideo.h
@@ -468,6 +468,7 @@ extern VideoBootStrap PSP_bootstrap;
 extern VideoBootStrap VITA_bootstrap;
 extern VideoBootStrap RISCOS_bootstrap;
 extern VideoBootStrap N3DS_bootstrap;
+extern VideoBootStrap OGC_bootstrap;
 extern VideoBootStrap RPI_bootstrap;
 extern VideoBootStrap KMSDRM_bootstrap;
 extern VideoBootStrap KMSDRM_LEGACY_bootstrap;
diff --git a/src/video/SDL_video.c b/src/video/SDL_video.c
index 8065a0b8c..e5412450c 100644
--- a/src/video/SDL_video.c
+++ b/src/video/SDL_video.c
@@ -110,6 +110,9 @@ static VideoBootStrap *bootstrap[] = {
 #if SDL_VIDEO_DRIVER_N3DS
     &N3DS_bootstrap,
 #endif
+#if SDL_VIDEO_DRIVER_OGC
+    &OGC_bootstrap,
+#endif
 #if SDL_VIDEO_DRIVER_KMSDRM
     &KMSDRM_bootstrap,
 #endif
diff --git a/src/video/ogc/SDL_ogcevents.c b/src/video/ogc/SDL_ogcevents.c
new file mode 100644
index 000000000..9451576f9
--- /dev/null
+++ b/src/video/ogc/SDL_ogcevents.c
@@ -0,0 +1,100 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifdef SDL_VIDEO_DRIVER_OGC
+
+#include "SDL.h"
+
+#include "../../events/SDL_events_c.h"
+
+#include "SDL_ogcevents_c.h"
+#include "SDL_ogcvideo.h"
+
+#include <ogc/system.h>
+#include <wiiuse/wpad.h>
+
+/* These variables can be set from the handlers registered in SDL_main() */
+bool OGC_PowerOffRequested = false;
+bool OGC_ResetRequested = false;
+
+#ifdef __wii__
+#define MAX_WII_MOUSE_BUTTONS 2
+static const struct {
+    int wii;
+    int mouse;
+} s_mouse_button_map[MAX_WII_MOUSE_BUTTONS] = {
+    { WPAD_BUTTON_B, SDL_BUTTON_LEFT },
+    { WPAD_BUTTON_A, SDL_BUTTON_RIGHT },
+};
+
+static void pump_ir_events(_THIS)
+{
+    if (!_this->windows) return;
+
+    if (!SDL_WasInit(SDL_INIT_JOYSTICK)) {
+        /* Get events from WPAD; we don't need to do this if the joystick
+         * system was initialized, because in that case this operation is done
+         * there at every event loop iteration. */
+        WPAD_ReadPending(WPAD_CHAN_ALL, NULL);
+    }
+
+    for (int i = 0; i < 4; i++) {
+        WPADData *data = WPAD_Data(i);
+
+        if (!data->ir.smooth_valid) continue;
+
+        SDL_SendMouseMotion(_this->windows, i,
+                            0, data->ir.sx, data->ir.sy);
+
+        for (int b = 0; b < MAX_WII_MOUSE_BUTTONS; b++) {
+            if (data->btns_d & s_mouse_button_map[b].wii) {
+                SDL_SendMouseButton(_this->windows, i,
+                                    SDL_PRESSED, s_mouse_button_map[b].mouse);
+            }
+            if (data->btns_u & s_mouse_button_map[b].wii) {
+                SDL_SendMouseButton(_this->windows, i,
+                                    SDL_RELEASED, s_mouse_button_map[b].mouse);
+            }
+        }
+    }
+}
+#endif
+
+void OGC_PumpEvents(_THIS)
+{
+    if (OGC_ResetRequested || OGC_PowerOffRequested) {
+        SDL_Event ev;
+        ev.type = SDL_QUIT;
+        SDL_PushEvent(&ev);
+        if (OGC_PowerOffRequested) {
+            SYS_ResetSystem(SYS_POWEROFF, 0, 0);
+        }
+    }
+
+#ifdef __wii__
+    pump_ir_events(_this);
+#endif
+}
+
+#endif /* SDL_VIDEO_DRIVER_OGC */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/ogc/SDL_ogcevents_c.h b/src/video/ogc/SDL_ogcevents_c.h
new file mode 100644
index 000000000..6bc6b91e6
--- /dev/null
+++ b/src/video/ogc/SDL_ogcevents_c.h
@@ -0,0 +1,36 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_ogcevents_c_h_
+#define SDL_ogcevents_c_h_
+
+#include "../../SDL_internal.h"
+
+#include "SDL_ogcvideo.h"
+
+extern bool OGC_ResetRequested;
+extern bool OGC_PowerOffRequested;
+
+extern void OGC_PumpEvents(_THIS);
+
+#endif /* SDL_ogcevents_c_h_ */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/ogc/SDL_ogcframebuffer.c b/src/video/ogc/SDL_ogcframebuffer.c
new file mode 100644
index 000000000..21fb7ee0c
--- /dev/null
+++ b/src/video/ogc/SDL_ogcframebuffer.c
@@ -0,0 +1,129 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifdef SDL_VIDEO_DRIVER_OGC
+
+#include "../SDL_sysvideo.h"
+#include "SDL_ogcframebuffer_c.h"
+#include "SDL_ogcgxcommon.h"
+#include "SDL_ogcpixels.h"
+#include "SDL_ogcvideo.h"
+
+#include <malloc.h>
+#include <ogc/cache.h>
+#include <ogc/gx.h>
+#include <ogc/system.h>
+#include <ogc/video.h>
+
+static void draw_screen_rect(SDL_Window *window)
+{
+    s16 z = 0;
+
+    GX_Begin(GX_QUADS, GX_VTXFMT0, 4);
+    GX_Position3s16(0, 0, z);
+    GX_TexCoord1x8(0);
+    GX_Position3s16(window->w, 0, z);
+    GX_TexCoord1x8(1);
+    GX_Position3s16(window->w, window->h, z);
+    GX_TexCoord1x8(2);
+    GX_Position3s16(0, window->h, z);
+    GX_TexCoord1x8(3);
+    GX_End();
+}
+
+static void free_window_data(SDL_Window *window)
+{
+    SDL_WindowData *windowdata = (SDL_WindowData *)window->driverdata;
+    if (windowdata) {
+        if (windowdata->pixels) {
+            SDL_free(windowdata->pixels);
+        }
+        if (windowdata->texels) {
+            free(windowdata->texels);
+        }
+        SDL_free(windowdata);
+        window->driverdata = NULL;
+    }
+}
+
+int SDL_OGC_CreateWindowFramebuffer(_THIS, SDL_Window *window, Uint32 *format, void **pixels, int *pitch)
+{
+    SDL_WindowData *windowdata;
+    int bytes_per_pixel = 4;
+    size_t texture_size;
+    int w, h;
+
+    free_window_data(window);
+    windowdata = (SDL_WindowData *)SDL_calloc(1, sizeof(SDL_WindowData));
+    if (!windowdata) {
+        SDL_OutOfMemory();
+        return -1;
+    }
+
+    w = window->w;
+    h = window->h;
+    windowdata->pixels = SDL_malloc(w * h * bytes_per_pixel);
+    texture_size = GX_GetTexBufferSize(w, h, GX_TF_RGBA8, GX_FALSE, 0);
+    windowdata->texels = memalign(32, texture_size);
+    windowdata->surface_format = SDL_PIXELFORMAT_RGBA8888;
+    window->driverdata = windowdata;
+
+    *pitch = w * bytes_per_pixel;
+    *format = windowdata->surface_format;
+    *pixels = windowdata->pixels;
+    return 0;
+}
+
+int SDL_OGC_UpdateWindowFramebuffer(_THIS, SDL_Window *window, const SDL_Rect *rects, int numrects)
+{
+    SDL_WindowData *windowdata = (SDL_WindowData *)window->driverdata;
+    u32 texture_size;
+    u8 gx_format;
+
+    gx_format = OGC_texture_format_from_SDL(windowdata->surface_format);
+    for (int i = 0; i < numrects; i++) {
+        OGC_pixels_to_texture(windowdata->pixels, windowdata->surface_format, &rects[i],
+                              window->surface->pitch, windowdata->texels, window->w);
+    }
+    texture_size = GX_GetTexBufferSize(window->w, window->h, gx_format,
+                                       GX_FALSE, 0);
+    DCStoreRange(windowdata->texels, texture_size);
+    GX_InvalidateTexAll();
+    OGC_load_texture(windowdata->texels, window->w, window->h, gx_format,
+                     SDL_ScaleModeNearest);
+    draw_screen_rect(window);
+    GX_DrawDone();
+
+    OGC_video_flip(_this, true);
+
+    return 0;
+}
+
+void SDL_OGC_DestroyWindowFramebuffer(_THIS, SDL_Window *window)
+{
+    SDL_LogDebug(SDL_LOG_CATEGORY_VIDEO, "Destroying window");
+    free_window_data(window);
+}
+
+#endif /* SDL_VIDEO_DRIVER_OGC */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/ogc/SDL_ogcframebuffer_c.h b/src/video/ogc/SDL_ogcframebuffer_c.h
new file mode 100644
index 000000000..af58bbcc1
--- /dev/null
+++ b/src/video/ogc/SDL_ogcframebuffer_c.h
@@ -0,0 +1,33 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_ogcframebuffer_c_h_
+#define SDL_ogcframebuffer_c_h_
+
+#include "../../SDL_internal.h"
+
+extern int SDL_OGC_CreateWindowFramebuffer(_THIS, SDL_Window *window, Uint32 *format, void **pixels, int *pitch);
+extern int SDL_OGC_UpdateWindowFramebuffer(_THIS, SDL_Window *window, const SDL_Rect *rects, int numrects);
+extern void SDL_OGC_DestroyWindowFramebuffer(_THIS, SDL_Window *window);
+
+#endif /* SDL_ogcframebuffer_c_h_ */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/ogc/SDL_ogcgxcommon.c b/src/video/ogc/SDL_ogcgxcommon.c
new file mode 100644
index 000000000..eeb1146ad
--- /dev/null
+++ b/src/video/ogc/SDL_ogcgxcommon.c
@@ -0,0 +1,149 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifdef SDL_VIDEO_DRIVER_OGC
+
+#include "SDL_ogcgxcommon.h"
+#include "SDL_ogcpixels.h"
+
+#include <ogc/cache.h>
+#include <ogc/gx.h>
+#include <ogc/video.h>
+
+typedef struct tagcamera {
+    guVector pos;
+    guVector up;
+    guVector view;
+} camera;
+
+static camera cam = {
+    { 0.0F, 0.0F, 0.0F },
+    { 0.0F, -0.5F, 0.0F },
+    { 0.0F, 0.0F, 0.5F }
+};
+
+static const f32 tex_pos[] __attribute__((aligned(32))) = {
+    0.0,
+    0.0,
+    1.0,
+    0.0,
+    1.0,
+    1.0,
+    0.0,
+    1.0,
+};
+
+void OGC_set_viewport(int x, int y, int w, int h, float h_aspect, float v_aspect)
+{
+    Mtx m, mv, view;
+    Mtx44 proj;
+
+    GX_SetViewport(x, y, w, h, 0, 1);
+    GX_SetScissor(x, y, w, h);
+
+    memset(&view, 0, sizeof(Mtx));
+    guLookAt(view, &cam.pos, &cam.up, &cam.view);
+    guMtxIdentity(m);
+    guMtxTransApply(m, m, 0.5 + (-w / 2.0), 0.5 + (-h / 2.0), 1000);
+    guMtxConcat(view, m, mv);
+    GX_LoadPosMtxImm(mv, GX_PNMTX0);
+
+    // matrix, t, b, l, r, n, f
+    guOrtho(proj, v_aspect, -v_aspect, -h_aspect, h_aspect, 100, 1000);
+    GX_LoadProjectionMtx(proj, GX_ORTHOGRAPHIC);
+}
+
+void OGC_draw_init(int w, int h, int h_aspect, int v_aspect)
+{
+    SDL_LogDebug(SDL_LOG_CATEGORY_VIDEO, "OGC_draw_init called with %d, %d", w, h);
+
+    GX_ClearVtxDesc();
+    GX_SetVtxDesc(GX_VA_POS, GX_DIRECT);
+    GX_SetVtxDesc(GX_VA_TEX0, GX_INDEX8);
+
+    GX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_S16, 0);
+    GX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_F32, 0);
+
+    GX_SetArray(GX_VA_TEX0, (void *)tex_pos, 2 * sizeof(f32));
+    GX_SetNumTexGens(1);
+    GX_SetNumChans(1);
+    GX_SetChanCtrl(GX_COLOR0A0, GX_DISABLE, GX_SRC_VTX, GX_SRC_VTX, 0,
+                   GX_DF_NONE, GX_AF_NONE);
+
+    GX_SetTexCoordGen(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY);
+
+    GX_SetTevOp(GX_TEVSTAGE0, GX_REPLACE);
+    GX_SetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR0A0);
+
+    OGC_set_viewport(0, 0, w, h, h_aspect, v_aspect);
+
+    GX_InvVtxCache(); // update vertex cache
+}
+
+void OGC_load_texture(void *texels, int w, int h, u8 format,
+                      SDL_ScaleMode scale_mode)
+{
+    GXTexObj texobj_a, texobj_b;
+
+    if (format == GX_TF_CI8) {
+        GX_InitTexObjCI(&texobj_a, texels, w, h, GX_TF_CI8, GX_CLAMP, GX_CLAMP, 0, GX_TLUT0);
+        GX_InitTexObjCI(&texobj_b, texels, w, h, GX_TF_CI8, GX_CLAMP, GX_CLAMP, 0, GX_TLUT1);
+        GX_LoadTexObj(&texobj_b, GX_TEXMAP1);
+
+        // Setup TEV to combine Red+Green and Blue paletted images
+        GX_SetTevColor(GX_TEVREG0, (GXColor){ 255, 255, 0, 0 });
+        GX_SetTevSwapModeTable(GX_TEV_SWAP1, GX_CH_RED, GX_CH_ALPHA, GX_CH_BLUE, GX_CH_ALPHA);
+        GX_SetTevSwapModeTable(GX_TEV_SWAP2, GX_CH_ALPHA, GX_CH_ALPHA, GX_CH_BLUE, GX_CH_ALPHA);
+        // first stage = red and green
+        GX_SetTevSwapMode(GX_TEVSTAGE0, GX_TEV_SWAP0, GX_TEV_SWAP1);
+        GX_SetTevColorIn(GX_TEVSTAGE0, GX_CC_ZERO, GX_CC_TEXC, GX_CC_C0, GX_CC_ZERO);
+        // second stage = add blue (and opaque alpha)
+        GX_SetTevOp(GX_TEVSTAGE1, GX_BLEND);
+        GX_SetTevOrder(GX_TEVSTAGE1, GX_TEXCOORD0, GX_TEXMAP1, GX_COLORNULL);
+        GX_SetTevSwapMode(GX_TEVSTAGE1, GX_TEV_SWAP0, GX_TEV_SWAP2);
+        GX_SetTevColorIn(GX_TEVSTAGE1, GX_CC_TEXC, GX_CC_ZERO, GX_CC_ZERO, GX_CC_CPREV);
+        GX_SetTevAlphaIn(GX_TEVSTAGE1, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, GX_CA_KONST);
+
+        GX_SetNumTevStages(2);
+    } else {
+        GX_InitTexObj(&texobj_a, texels, w, h, format, GX_CLAMP, GX_CLAMP, GX_FALSE);
+    }
+
+    switch (scale_mode) {
+    case SDL_ScaleModeLinear:
+        GX_InitTexObjLOD(&texobj_a, GX_LINEAR, GX_LINEAR,
+                         0.0f, 0.0f, 0.0f, 0, 0, GX_ANISO_1);
+        break;
+    case SDL_ScaleModeBest:
+        GX_InitTexObjLOD(&texobj_a, GX_LIN_MIP_LIN, GX_LINEAR,
+                         0.0f, 10.0f, 0.0f, 0, GX_ENABLE, GX_ANISO_4);
+        break;
+    default:
+        GX_InitTexObjLOD(&texobj_a, GX_NEAR, GX_NEAR,
+                         0.0f, 0.0f, 0.0f, 0, 0, GX_ANISO_1);
+    }
+    GX_LoadTexObj(&texobj_a, GX_TEXMAP0); // load texture object so its ready to use
+}
+
+#endif /* SDL_VIDEO_DRIVER_OGC */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/ogc/SDL_ogcgxcommon.h b/src/video/ogc/SDL_ogcgxcommon.h
new file mode 100644
index 000000000..fe3360fe0
--- /dev/null
+++ b/src/video/ogc/SDL_ogcgxcommon.h
@@ -0,0 +1,39 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef SDL_ogcgxcommon_h_
+#define SDL_ogcgxcommon_h_
+
+#include "SDL_render.h"
+
+#include <gctypes.h>
+
+#define GX_COLOR_AS_U32(c) *((u32*)&c)
+
+void OGC_draw_init(int w, int h, int h_aspect, int v_aspect);
+void OGC_set_viewport(int x, int y, int w, int h, float h_aspect, float v_aspect);
+void OGC_load_texture(void *texels, int w, int h, u8 gx_format,
+                      SDL_ScaleMode scale_mode);
+
+#endif /* SDL_ogcgxcommon_h_ */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/ogc/SDL_ogcpixels.c b/src/video/ogc/SDL_ogcpixels.c
new file mode 100644
index 000000000..2d87b40d9
--- /dev/null
+++ b/src/video/ogc/SDL_ogcpixels.c
@@ -0,0 +1,355 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#include "SDL_ogcpixels.h"
+
+#include <ogc/gx.h>
+
+#define PIXELS_TO_TEXTURE_32(format_func) \
+    static void pixels_to_texture_ ## format_func( \
+        void *pixels, const SDL_Rect *rect, int16_t pitch, void *texture, int16_t tex_width) \
+    { \
+        int16_t tex_pitch = (tex_width + 3) / 4 * 4; \
+        for (int row = 0; row < rect->h; row++) { \
+            int y = rect->y + row; \
+            u32 *src = (u32 *)((u8 *)pixels + pitch * row); \
+            for (int col = 0; col < rect->w; col++) { \
+                int x = rect->x + col; \
+                u32 offset = (((y >> 2) << 4) * tex_pitch) + \
+                    ((x >> 2) << 6) + (((y % 4 << 2) + x % 4) << 1); \
+                set_pixel_to_texture_ ## format_func(texture, offset, *src++); \
+            } \
+        } \
+    }
+
+#define PIXELS_FROM_TEXTURE_32(format_func) \
+    static void pixels_from_texture_ ## format_func( \
+        void *pixels, int16_t w, int16_t h, int16_t pitch, void *texture) \
+    { \
+        int tex_width = (w + 3) / 4 * 4; \
+        for (int y = 0; y < h; y++) { \
+            u32 *dst = (u32 *)((u8 *)pixels + pitch * y); \
+            for (int x = 0; x < w; x++) { \
+                u32 offset = (((y >> 2) << 4) * tex_width) + \
+                    ((x >> 2) << 6) + (((y % 4 << 2) + x % 4) << 1); \
+                *dst++ = get_pixel_from_texture_ ## format_func(texture, offset); \
+            } \
+        } \
+    }
+
+static u8 texture_format_from_SDL(const SDL_PixelFormatEnum format)
+{
+    switch (format) {
+    case SDL_PIXELFORMAT_INDEX8:
+        return GX_TF_CI8;
+    case SDL_PIXELFORMAT_RGB565:
+        return GX_TF_RGB565;
+    case SDL_PIXELFORMAT_RGB24:
+    case SDL_PIXELFORMAT_RGBA8888:
+    case SDL_PIXELFORMAT_ARGB8888:
+    case SDL_PIXELFORMAT_XRGB8888:
+        return GX_TF_RGBA8;
+    default:
+        SDL_LogError(SDL_LOG_CATEGORY_VIDEO,
+                     "(texture_format_from_SDL) Unsupported SDL pixel format %d",
+                     format);
+    }
+    return 0xff; // invalid
+}
+
+static inline void set_pixel_to_texture_ARGB(void *texture, u32 offset, u32 color)
+{
+    *(u16*)(texture + offset) = color >> 16;
+    *(u16*)(texture + offset + 32) = color;
+}
+
+static inline u32 get_pixel_from_texture_ARGB(void *texture, u32 offset)
+{
+    return *(u16*)(texture + offset) << 16 |
+           *(u16*)(texture + offset + 32);
+}
+
+static inline void set_pixel_to_texture_RGBA(void *texture, u32 offset, u32 color)
+{
+    set_pixel_to_texture_ARGB(texture, offset, (color << 24) | (color >> 8));
+}
+
+static inline u32 get_pixel_from_texture_32(int x, int y, void *texture, int tex_width)
+{
+    u8 *tex = texture;
+    u32 offset;
+
+    offset = (((y >> 2) << 4) * tex_width) + ((x >> 2) << 6) + (((y % 4 << 2) + x % 4) << 1);
+
+    return *(tex + offset) |
+           *(tex + offset + 1) << 24 |
+           *(tex + offset + 32) << 16 |
+           *(tex + offset + 33) << 8;
+}
+
+PIXELS_TO_TEXTURE_32(RGBA)
+
+static void pixels_RGBA_from_texture(void *pixels, int16_t w, int16_t h,
+                                     int16_t pitch, void *texture)
+{
+    u32 *dst = pixels;
+
+    int tex_width = (w + 3) / 4 * 4;
+    for (int y = 0; y < h; y++) {
+        dst = (u32 *)((u8 *)pixels + pitch * y);
+        for (int x = 0; x < w; x++) {
+            *dst++ = get_pixel_from_texture_32(x, y, texture, tex_width);
+        }
+    }
+}
+
+PIXELS_TO_TEXTURE_32(ARGB)
+PIXELS_FROM_TEXTURE_32(ARGB)
+
+static inline void set_pixel_to_texture_XRGB(void *texture, u32 offset, u32 color)
+{
+    set_pixel_to_texture_ARGB(texture, offset, 0xff000000 | color);
+}
+
+PIXELS_TO_TEXTURE_32(XRGB)
+
+static void pixels_XRGB_from_texture(void *pixels, int16_t w, int16_t h,
+                                     int16_t pitch, void *texture)
+{
+    u32 *dst = pixels;
+
+    int tex_width = (w + 3) / 4 * 4;
+    for (int y = 0; y < h; y++) {
+        dst = (u32 *)((u8 *)pixels + pitch * y);
+        for (int x = 0; x < w; x++) {
+            *dst++ = get_pixel_from_texture_32(x, y, texture, tex_width) >> 8;
+        }
+    }
+}
+
+static void pixels_RGB_to_texture(void *pixels, const SDL_Rect *rect,
+                                  int16_t pitch, void *texture, int16_t tex_width)
+{
+    u8 *src = pixels;
+
+    int tex_pitch = (tex_width + 3) / 4 * 4;
+    for (int row = 0; row < rect->h; row++) {
+        int y = rect->y + row;
+        src = (u8 *)pixels + pitch * row;
+        for (int col = 0; col < rect->w; col++) {
+            int x = rect->x + col;
+            u32 offset = (((y >> 2) << 4) * tex_pitch) +
+                ((x >> 2) << 6) + (((y % 4 << 2) + x % 4) << 1);
+            u8 r = *src++;
+            u8 g = *src++;
+            u8 b = *src++;
+            set_pixel_to_texture_ARGB(texture, offset, 0xff000000 | r << 16 | g << 8 | b);
+        }
+    }
+}
+
+static void pixels_RGB_from_texture(void *pixels, int16_t w, int16_t h,
+                                    int16_t pitch, void *texture)
+{
+    u8 *dst = pixels;
+
+    int tex_width = (w + 3) / 4 * 4;
+    for (int y = 0; y < h; y++) {
+        dst = (u8 *)pixels + pitch * y;
+        for (int x = 0; x < w; x++) {
+            u32 color = get_pixel_from_texture_32(x, y, texture, tex_width);
+            *dst++ = color >> 24;
+            *dst++ = color >> 16;
+            *dst++ = color >> 8;
+        }
+    }
+}
+
+static void pixels_16_to_texture(void *pixels, const SDL_Rect *rect, int16_t pitch,
+                                 void *texture, int16_t tex_width)
+{
+    /* We only support coordinates multiple of 4. While we don't add support
+     * for arbitrary coordinates (TODO), let's restrict the paint area to the
+     * full 4x4 cells covered by the rect. In the future we can add code to
+     * fill up the remaining borders. */
+    int x0 = (rect->x + 3) & ~0x3;
+    int x1 = (rect->x + rect->w) & ~0x3;
+    int y0 = (rect->y + 3) & ~0x3;
+    int y1 = (rect->y + rect->h) & ~0x3;
+    int skipped_bytes_left = (x0 - rect->x) * 2;
+    int tex_pitch = tex_width * 2;
+
+
+    for (int row = 0; row < y1 - y0; row += 4) {
+        u64 *src1 = pixels + (skipped_bytes_left + row * pitch);
+        u64 *src2 = (void*)src1 + (pitch * 1);
+        u64 *src3 = (void*)src1 + (pitch * 2);
+        u64 *src4 = (void*)src1 + (pitch * 3);
+        u64 *dst = texture + (x0 * 8 + (y0 + row) * tex_pitch);
+        for (int col = x0; col < x1; col += 4) {
+            *dst++ = *src1++;
+            *dst++ = *src2++;
+            *dst++ = *src3++;
+            *dst++ = *src4++;
+        }
+    }
+}
+
+static void pixels_16_from_texture(void *pixels, int16_t pitch, int16_t h,
+                                   void *texture)
+{
+    long long int *src = texture;
+    long long int *dst1 = pixels;
+    long long int *dst2 = (long long int *)((char *)pixels + (pitch * 1));
+    long long int *dst3 = (long long int *)((char *)pixels + (pitch * 2));
+    long long int *dst4 = (long long int *)((char *)pixels + (pitch * 3));
+    int rowpitch = (pitch >> 3) * 3;
+
+    for (int y = 0; y < h; y += 4) {
+        for (int x = 0; x < pitch; x += 8) {
+            *dst1++ = *src++;
+            *dst2++ = *src++;
+            *dst3++ = *src++;
+            *dst4++ = *src++;
+        }
+
+        dst1 = dst4;
+        dst2 += rowpitch;
+        dst3 += rowpitch;
+        dst4 += rowpitch;
+    }
+}
+
+static inline void set_pixel_8_to_texture(int x, int y, u8 color, void *texture, int tex_width)
+{
+    u8 *tex = texture;
+    u32 offset;
+
+    offset = ((y & ~3) * tex_width) + ((x & ~7) << 2) + ((y & 3) << 3) + (x & 7);
+
+    tex[offset] = color;
+}
+
+static inline u8 get_pixel_8_from_texture(int x, int y, void *texture, int tex_width)
+{
+    u8 *tex = texture;
+    u32 offset;
+
+    offset = ((y & ~3) * tex_width) + ((x & ~7) << 2) + ((y & 3) << 3) + (x & 7);
+
+    return tex[offset];
+}
+
+static void pixels_8_to_texture(void *pixels, int16_t w, int16_t h,
+                                int16_t pitch, void *texture)
+{
+    u8 *src = pixels;
+    int tex_width = (w + 7) / 8 * 8;
+
+    for (int y = 0; y < h; y++) {
+        src = (u8 *)pixels + pitch * y;
+        for (int x = 0; x < w; x++) {
+            set_pixel_8_to_texture(x, y, *src++, texture, tex_width);
+        }
+    }
+}
+
+static void pixels_8_from_texture(void *pixels, int16_t w, int16_t h,
+                                  int16_t pitch, void *texture)
+{
+    u8 *dst = pixels;
+    int tex_width = (w + 7) / 8 * 8;
+
+    for (int y = 0; y < h; y++) {
+        dst = (u8 *)pixels + pitch * y;
+        for (int x = 0; x < w; x++) {
+            *dst++ = get_pixel_8_from_texture(x, y, texture, tex_width);
+        }
+    }
+}
+
+void OGC_pixels_to_texture(void *pixels, const SDL_PixelFormatEnum format,
+                           const SDL_Rect *rect, int16_t pitch,
+                           void *texture, int16_t tex_width)
+{
+    switch (format) {
+    case SDL_PIXELFORMAT_INDEX8:
+        pixels_8_to_texture(pixels, rect->w, rect->h, pitch, texture);
+        break;
+    case SDL_PIXELFORMAT_RGB565:
+        pixels_16_to_texture(pixels, rect, pitch, texture, tex_width);
+        break;
+    case SDL_PIXELFORMAT_RGB24:
+        pixels_RGB_to_texture(pixels, rect, pitch, texture, tex_width);
+        break;
+    case SDL_PIXELFORMAT_RGBA8888:
+        pixels_to_texture_RGBA(pixels, rect, pitch, texture, tex_width);
+        break;
+    case SDL_PIXELFORMAT_ARGB8888:
+        pixels_to_texture_ARGB(pixels, rect, pitch, texture, tex_width);
+        break;
+    case SDL_PIXELFORMAT_XRGB8888:
+        pixels_to_texture_XRGB(pixels, rect, pitch, texture, tex_width);
+        break;
+    default:
+        SDL_LogError(SDL_LOG_CATEGORY_VIDEO,
+                     "ptt: unsupported SDL pixel format %d", format);
+        // TODO support more formats
+    }
+}
+
+void OGC_pixels_from_texture(void *pixels, const SDL_PixelFormatEnum format,
+                             int16_t w, int16_t h, int16_t pitch,
+                             void *texture)
+{
+    switch (format) {
+    case SDL_PIXELFORMAT_INDEX8:
+        pixels_8_from_texture(pixels, w, h, pitch, texture);
+        break;
+    case SDL_PIXELFORMAT_RGB565:
+        pixels_16_from_texture(pixels, pitch, h, texture);
+        break;
+    case SDL_PIXELFORMAT_RGB24:
+        pixels_RGB_from_texture(pixels, w, h, pitch, texture);
+        break;
+    case SDL_PIXELFORMAT_RGBA8888:
+        pixels_RGBA_from_texture(pixels, w, h, pitch, texture);
+        break;
+    case SDL_PIXELFORMAT_ARGB8888:
+        pixels_from_texture_ARGB(pixels, w, h, pitch, texture);
+        break;
+    case SDL_PIXELFORMAT_XRGB8888:
+        pixels_XRGB_from_texture(pixels, w, h, pitch, texture);
+        break;
+    default:
+        SDL_LogError(SDL_LOG_CATEGORY_VIDEO,
+                     "pft: unsupported SDL pixel format %d", format);
+        // TODO support more formats
+    }
+}
+
+u8 OGC_texture_format_from_SDL(const SDL_PixelFormatEnum format)
+{
+    return texture_format_from_SDL(format);
+}
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/ogc/SDL_ogcpixels.h b/src/video/ogc/SDL_ogcpixels.h
new file mode 100644
index 000000000..c92d032aa
--- /dev/null
+++ b/src/video/ogc/SDL_ogcpixels.h
@@ -0,0 +1,42 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef SDL_ogcpixels_h_
+#define SDL_ogcpixels_h_
+
+#include "SDL_pixels.h"
+#include "SDL_rect.h"
+
+#include <gctypes.h>
+
+void OGC_pixels_to_texture(void *pixels, SDL_PixelFormatEnum format,
+                           const SDL_Rect *rect, int16_t pitch,
+                           void *texels, int16_t tex_width);
+void OGC_pixels_from_texture(void *pixels, SDL_PixelFormatEnum format,
+                             int16_t w, int16_t h, int16_t pitch,
+                             void *texels);
+
+u8 OGC_texture_format_from_SDL(const SDL_PixelFormatEnum format);
+
+#endif /* SDL_ogcpixels_h_ */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/ogc/SDL_ogcvideo.c b/src/video/ogc/SDL_ogcvideo.c
new file mode 100644
index 000000000..b86da4ec6
--- /dev/null
+++ b/src/video/ogc/SDL_ogcvideo.c
@@ -0,0 +1,197 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifdef SDL_VIDEO_DRIVER_OGC
+
+#include "../../events/SDL_events_c.h"
+#include "../SDL_pixels_c.h"
+#include "../SDL_sysvideo.h"
+#include "SDL_mouse.h"
+#include "SDL_video.h"
+
+#include "SDL_hints.h"
+#include "SDL_ogcevents_c.h"
+#include "SDL_ogcframebuffer_c.h"
+#include "SDL_ogcgxcommon.h"
+#include "SDL_ogcvideo.h"
+
+#include <malloc.h>
+#include <ogc/color.h>
+#include <ogc/gx.h>
+#include <ogc/system.h>
+#include <ogc/video.h>
+
+#define DEFAULT_FIFO_SIZE 256 * 1024
+
+/* Initialization/Query functions */
+static int OGC_VideoInit(_THIS);
+static void OGC_VideoQuit(_THIS);
+
+/* OGC driver bootstrap functions */
+
+static void OGC_DeleteDevice(SDL_VideoDevice *device)
+{
+    SDL_free(device->driverdata);
+    SDL_free(device);
+}
+
+static SDL_VideoDevice *OGC_CreateDevice(void)
+{
+    SDL_VideoDevice *device;
+    SDL_VideoData *videodata;
+
+    /* Initialize all variables that we clean on shutdown */
+    device = (SDL_VideoDevice *)SDL_calloc(1, sizeof(SDL_VideoDevice));
+    if (!device) {
+        SDL_OutOfMemory();
+        return NULL;
+    }
+
+    videodata = (SDL_VideoData *)SDL_calloc(1, sizeof(SDL_VideoData));
+    if (!videodata) {
+        SDL_OutOfMemory();
+        SDL_free(device);
+        return NULL;
+    }
+
+    device->driverdata = videodata;
+
+    /* Set the function pointers */
+    device->VideoInit = OGC_VideoInit;
+    device->VideoQuit = OGC_VideoQuit;
+    device->PumpEvents = OGC_PumpEvents;
+    device->CreateWindowFramebuffer = SDL_OGC_CreateWindowFramebuffer;
+    device->UpdateWindowFramebuffer = SDL_OGC_UpdateWindowFramebuffer;
+    device->DestroyWindowFramebuffer = SDL_OGC_DestroyWindowFramebuffer;
+
+    device->free = OGC_DeleteDevice;
+
+    return device;
+}
+
+VideoBootStrap OGC_bootstrap = {
+    "ogc-video", "ogc video driver",
+    OGC_CreateDevice
+};
+
+int OGC_VideoInit(_THIS)
+{
+    SDL_VideoData *videodata = (SDL_VideoData *)_this->driverdata;
+    SDL_DisplayMode mode;
+    GXRModeObj *vmode;
+    static const GXColor background = { 0, 0, 0, 255 };
+    int h_aspect, v_aspect;
+
+    VIDEO_Init();
+
+    vmode = VIDEO_GetPreferredMode(NULL);
+    VIDEO_Configure(vmode);
+
+    /* Allocate the XFB */
+    videodata->xfb[0] = MEM_K0_TO_K1(SYS_AllocateFramebuffer(vmode));
+    videodata->xfb[1] = MEM_K0_TO_K1(SYS_AllocateFramebuffer(vmode));
+
+    VIDEO_ClearFrameBuffer(vmode, videodata->xfb[0], COLOR_BLACK);
+    VIDEO_SetNextFramebuffer(videodata->xfb[0]);
+    VIDEO_SetBlack(false);
+    VIDEO_Flush();
+
+    videodata->gp_fifo = memalign(32, DEFAULT_FIFO_SIZE);
+    memset(videodata->gp_fifo, 0, DEFAULT_FIFO_SIZE);
+    GX_Init(videodata->gp_fifo, DEFAULT_FIFO_SIZE);
+
+    /* Setup the EFB -> XFB copy operation */
+    GX_SetDispCopySrc(0, 0, vmode->fbWidth, vmode->efbHeight);
+    GX_SetDispCopyDst(vmode->fbWidth, vmode->xfbHeight);
+    GX_SetDispCopyYScale((f32)vmode->xfbHeight / (f32)vmode->efbHeight);
+    GX_SetCopyFilter(vmode->aa, vmode->sample_pattern, GX_FALSE, vmode->vfilter);
+    GX_SetCopyClear(background, GX_MAX_Z24);
+
+    GX_SetFieldMode(vmode->field_rendering,
+                    ((vmode->viHeight == 2 * vmode->xfbHeight) ? GX_ENABLE : GX_DISABLE));
+    GX_SetPixelFmt(GX_PF_RGB8_Z24, GX_ZC_LINEAR);
+    GX_SetCullMode(GX_CULL_NONE);
+    GX_SetBlendMode(GX_BM_NONE, GX_BL_SRCALPHA, GX_BL_INVSRCALPHA, GX_LO_CLEAR);
+
+    GX_SetZMode(GX_TRUE, GX_LEQUAL, GX_TRUE);
+
+    /* Should we need to adjust the aspect, this is the place to do it */
+    h_aspect = 320;
+    v_aspect = 240;
+    OGC_draw_init(vmode->fbWidth, vmode->efbHeight, h_aspect, v_aspect);
+
+    GX_Flush();
+
+    /* Use a fake 32-bpp desktop mode */
+    SDL_zero(mode);
+    mode.format = SDL_PIXELFORMAT_ARGB8888;
+    mode.w = vmode->fbWidth;
+    mode.h = vmode->xfbHeight;
+    mode.refresh_rate = 60;
+    mode.driverdata = NULL;
+    if (SDL_AddBasicVideoDisplay(&mode) < 0) {
+        return -1;
+    }
+
+    SDL_AddDisplayMode(&_this->displays[0], &mode);
+
+    videodata->vmode = vmode;
+    return 0;
+}
+
+void OGC_VideoQuit(_THIS)
+{
+    SDL_VideoData *videodata = (SDL_VideoData *)_this->driverdata;
+
+    SDL_free(videodata->gp_fifo);
+    if (videodata->xfb[0])
+        free(MEM_K1_TO_K0(videodata->xfb[0]));
+    if (videodata->xfb[1])
+        free(MEM_K1_TO_K0(videodata->xfb[1]));
+}
+
+void *OGC_video_get_xfb(_THIS)
+{
+    SDL_VideoData *videodata = _this->driverdata;
+    return videodata->xfb[videodata->fb_index];
+}
+
+void OGC_video_flip(_THIS, bool vsync)
+{
+    SDL_VideoData *videodata = _this->driverdata;
+    void *xfb = OGC_video_get_xfb(_this);
+    GX_CopyDisp(xfb, GX_TRUE);
+    GX_DrawDone();
+    GX_Flush();
+
+    VIDEO_SetNextFramebuffer(xfb);
+    VIDEO_Flush();
+    if (vsync) {
+        VIDEO_WaitVSync();
+    }
+
+    videodata->fb_index ^= 1;
+}
+
+#endif /* SDL_VIDEO_DRIVER_OGC */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/ogc/SDL_ogcvideo.h b/src/video/ogc/SDL_ogcvideo.h
new file mode 100644
index 000000000..3821d1966
--- /dev/null
+++ b/src/video/ogc/SDL_ogcvideo.h
@@ -0,0 +1,50 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef SDL_ogcvideo_h_
+#define SDL_ogcvideo_h_
+
+#include "../SDL_sysvideo.h"
+
+#include <ogc/gx_struct.h>
+
+typedef struct SDL_VideoData
+{
+    GXRModeObj *vmode;
+    u8 *gp_fifo;
+    void *xfb[2];
+    u8 fb_index;
+} SDL_VideoData;
+
+typedef struct SDL_WindowData
+{
+    void *pixels;
+    u8 *texels;
+    SDL_PixelFormatEnum surface_format;
+} SDL_WindowData;
+
+void *OGC_video_get_xfb(SDL_VideoDevice *device);
+void OGC_video_flip(SDL_VideoDevice *device, bool vsync);
+
+#endif /* SDL_ogcvideo_h_ */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt
index 52a268561..4cf924dd9 100644
--- a/test/CMakeLists.txt
+++ b/test/CMakeLists.txt
@@ -36,6 +36,10 @@ if(N3DS)
     link_libraries(SDL2::SDL2main)
 endif()
 
+if(OGC)
+    link_libraries(SDL2::SDL2main)
+endif()
+
 if(PSP)
     link_libraries(
         SDL2::SDL2main
